# Lec-61

## File I/O in C++: Read/Write in the Same Program & Closing Files:

## ✅ Required Header

```cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
```

---

## 📌 Goal

We’ll:

1. Write data to a file
2. Read that same data from the file
3. Properly close the file in between

---

## ✍️✅ Step-by-Step Example

```cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main() {
    fstream file;

    // Step 1: Write to file
    file.open("data.txt", ios::out);  // open for writing
    if (file.is_open()) {
        file << "Hello, File I/O in C++!\n";
        file << "This is line 2.\n";
        file.close();  // ✅ close the file after writing
        cout << "Data written successfully.\n";
    } else {
        cout << "Unable to open file for writing.\n";
    }

    // Step 2: Read from same file
    file.open("data.txt", ios::in);  // open for reading
    if (file.is_open()) {
        string line;
        cout << "\nReading from file:\n";
        while (getline(file, line)) {
            cout << line << endl;
        }
        file.close();  // ✅ close the file after reading
    } else {
        cout << "Unable to open file for reading.\n";
    }

    return 0;
}
```

---

## 🧾 Sample Output:

```
Data written successfully.

Reading from file:
Hello, File I/O in C++!
This is line 2.
```

---

## ✅ Why We Use `file.close()`

| Reason                         | Explanation                                      |
| ------------------------------ | ------------------------------------------------ |
| 🧹 Free up resources           | Releases the file handle                         |
| ✅ Saves written data           | Ensures all buffered data is flushed to disk     |
| 📦 Opens file for another mode | You can’t write → read unless you close & reopen |
| ❌ Prevents file corruption     | Especially in larger or binary files             |

---

## 🛠 Alternate: Using `fstream` for Both Read/Write Together

You can combine flags:

```cpp
fstream file("data.txt", ios::in | ios::out);
```

But make sure:

* The file **already exists** when using `ios::in`
* You manage the read/write **position** correctly using `seekg()` or `seekp()` if needed

---

## 🧠 Bonus Tip

You can check if the file opened successfully:

```cpp
if (!file) {
    cout << "File open failed!\n";
}
```

---

## ✅ Summary

| Task                    | Stream/Class   | Mode Used         | Close Required |       |
| ----------------------- | -------------- | ----------------- | -------------- | ----- |
| Write to a file         | `fstream`      | `ios::out`        | ✅ Yes          |       |
| Read from a file        | `fstream`      | `ios::in`         | ✅ Yes          |       |
| Read and write together | `fstream`      | \`ios::in         | ios::out\`     | ✅ Yes |
| Close the file          | `file.close()` | Always after done | ✅ Must         |       |

---

## ✅ Practice Suggestion

Try creating a program that:

* Takes student data (name & marks) as input and saves it to a file
* Then reads all records and displays them

Would you like an example for that?
Or do you want to learn how to **append** or **handle binary files** next?

---
---

# Lec-62

## File I/O in C++: open() and eof() functions:

## ✅ 1. `open()` Function

### 📌 What it does:

The `open()` function is used to **open a file explicitly** using a file stream object (`ifstream`, `ofstream`, or `fstream`).

---

### 🔧 Syntax:

```cpp
fstream file;
file.open("filename.txt", ios::mode);
```

---

### 🎯 Modes you can pass:

| Mode          | Description                            |                |
| ------------- | -------------------------------------- | -------------- |
| `ios::in`     | Open file for reading                  |                |
| `ios::out`    | Open file for writing (truncates file) |                |
| `ios::app`    | Append to file                         |                |
| `ios::binary` | Open file in binary mode               |                |
| `ios::ate`    | Move pointer to end of file on open    |                |
| \`ios::in     | ios::out\`                             | Read and write |

---

### 🧪 Example: Using `open()`

```cpp
#include <fstream>
#include <iostream>
using namespace std;

int main() {
    ofstream file;
    file.open("test.txt", ios::out);  // open file for writing

    if (file.is_open()) {
        file << "Hello using open()!\n";
        file.close();
    } else {
        cout << "Failed to open the file.\n";
    }

    return 0;
}
```

---

## ✅ 2. `eof()` Function

### 📌 What it does:

The `eof()` function stands for **End Of File**. It returns `true` when the file pointer has reached the **end** of the file.

---

### 🔧 Syntax:

```cpp
while (!file.eof()) {
    // read from file
}
```

⚠️ However, `eof()` only becomes `true **after** a failed read`.
So, it's **not recommended** as the loop condition. Better to use `getline()` or stream extraction (`>>`) directly.

---

### 🧪 Example: Using `eof()` to Read File

```cpp
#include <fstream>
#include <iostream>
using namespace std;

int main() {
    ifstream file("test.txt");
    string line;

    if (file.is_open()) {
        while (!file.eof()) {
            getline(file, line);
            if (!file.eof())  // Avoid printing extra line
                cout << line << endl;
        }
        file.close();
    } else {
        cout << "File not found!\n";
    }

    return 0;
}
```

---

### 🚫 Better Alternative:

```cpp
while (getline(file, line)) {
    cout << line << endl;
}
```

✅ This is safer and more accurate than using `.eof()`.

---

## 📝 Summary Table

| Function | Use                                    |
| -------- | -------------------------------------- |
| `open()` | Opens file with specific mode manually |
| `eof()`  | Checks if file pointer has reached end |

---

## 🧠 Real-Life Analogy

* `open()` = Opening a **book** to read or write
* `eof()` = Reaching the **last page** of the book

---

## ✅ Bonus Tip

You can **check if a file exists** before using it:

```cpp
ifstream check("file.txt");
if (!check) {
    cout << "File does not exist.\n";
}
```

---
---

# Lec-63 & 64

## C++ Templates: Must for Competitive Programming:
## Writing our First C++ Template in VS Code:

In **competitive programming**, **C++ templates** are a powerful feature that lets you write **generic, reusable, and fast code** — especially for **data structures**, **algorithms**, and **utility functions**.

---

# 🧠 C++ Templates: Must-Know for Competitive Programming

---

## ✅ What is a Template in C++?

> A **template** allows you to write a function or class **without specifying the exact data type**.
> The **compiler automatically generates** the correct version during compilation based on usage.

---

## 📌 Types of Templates

| Type                  | Purpose                                             |
| --------------------- | --------------------------------------------------- |
| **Function Template** | Generic functions for any data type                 |
| **Class Template**    | Generic data structures (like stacks, queues, etc.) |

---

## 🔹 Function Template – Example

```cpp
#include <iostream>
using namespace std;

template <typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    cout << getMax(3, 7) << endl;        // ints
    cout << getMax(3.5, 2.1) << endl;    // doubles
    cout << getMax('a', 'z') << endl;    // chars
    return 0;
}
```

🧾 Output:

```
7  
3.5  
z
```

✅ Same function works for multiple types — saves time and avoids code duplication.

---

## 🔹 Class Template – Example

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Pair {
    T x, y;
public:
    Pair(T a, T b) {
        x = a;
        y = b;
    }

    T getMax() {
        return (x > y) ? x : y;
    }
};

int main() {
    Pair<int> p1(10, 20);
    cout << p1.getMax() << endl;

    Pair<double> p2(3.14, 2.71);
    cout << p2.getMax() << endl;

    return 0;
}
```

---

## ✅ Why Templates Are 💎 Must-Have in Competitive Programming

| Benefit                    | How it Helps in CP                                  |
| -------------------------- | --------------------------------------------------- |
| ✅ Less code duplication    | One function/class handles many types               |
| ✅ Faster coding            | Useful when racing against the clock ⏱️             |
| ✅ Reusability              | Reuse for integers, floats, long long, etc.         |
| ✅ Works with STL           | STL containers (like `vector`, `map`) use templates |
| ✅ Efficient with recursion | Generic recursion/backtracking helpers              |

---

## 🏁 Competitive Programming Snippet

```cpp
template <typename T>
void printArray(vector<T>& arr) {
    for (T val : arr)
        cout << val << " ";
    cout << "\n";
}
```

Can be used with:

```cpp
vector<int> a = {1, 2, 3};
vector<char> b = {'a', 'b', 'c'};
printArray(a);
printArray(b);
```

---

## 🧠 Pro Tip: Template with Multiple Types

```cpp
template <typename T1, typename T2>
void printPair(T1 a, T2 b) {
    cout << a << " - " << b << "\n";
}
```

Call with:

```cpp
printPair("Age", 25);
printPair(1.23, "pi");
```

---

## 🧱 STL: Based Entirely on Templates

| STL Type       | Template Syntax Used           |
| -------------- | ------------------------------ |
| `vector<T>`    | `template<class T>`            |
| `map<K, V>`    | `template<class K, class V>`   |
| `pair<T1, T2>` | `template<class T1, class T2>` |

---

## 📌 Summary

| Concept           | Use in CP                          |
| ----------------- | ---------------------------------- |
| Function Template | Generic max/min, print, swap, etc. |
| Class Template    | Custom stacks, pairs, heaps        |
| STL               | Entirely template-based            |
| Time Efficiency   | Less typing, faster debugging      |
| Competitive Edge  | Write once, use everywhere 🏆      |

---

## 🛠 Suggested Practice

Try building:

* `template<typename T> T gcd(T a, T b);`
* `template<typename T> void swapValues(T &a, T &b);`
* Your own `Stack<T>` using class template

---
---

# Lec-65

## C++ Templates: Templates with Multiple Parameters:

---

## 📌 Syntax

```cpp
template <typename T1, typename T2>
return_type functionName(T1 a, T2 b) {
    // logic
}
```

---

## 🔹 Simple Example: Adding Different Types

```cpp
#include <iostream>
using namespace std;

template <typename T1, typename T2>
void add(T1 a, T2 b) {
    cout << "Sum is: " << a + b << endl;
}

int main() {
    add(10, 20);         // both int
    add(3.5, 2);         // double + int
    add(5, 2.7f);        // int + float
    return 0;
}
```

---

## 🧾 Output:

```
Sum is: 30  
Sum is: 5.5  
Sum is: 7.7
```

---

## ✅ Explanation

| Line                        | What It Does                             |
| --------------------------- | ---------------------------------------- |
| `template<typename T1, T2>` | Declares a template with 2 types         |
| `void add(T1 a, T2 b)`      | Works with **any** two data types        |
| `a + b`                     | Automatically uses correct data type sum |
| `add(...)`                  | Compiler generates proper version        |

---

## 🎯 Why Useful?

* Makes your code flexible
* Avoids writing multiple functions for each type
* Perfect for **utility functions**, **data structures**, **input/output wrappers** in **competitive programming**

---

## ✅ Challenge (Optional)

Try this yourself:

```cpp
template <typename T1, typename T2>
void printPair(T1 a, T2 b) {
    cout << "First: " << a << ", Second: " << b << endl;
}
```

Call:

```cpp
printPair("Score", 99);
printPair(3.14, "Pi");
```

---
---

# Lec-66

## C++ Templates: Class Templates with Default Parameters:

## 📌 What is it?

> A **class template with default parameters** allows you to **set default data types**, so users **don’t need to specify them** unless they want to change them.

---

### ✅ Syntax:

```cpp
template <typename T1 = int, typename T2 = float>
class MyClass {
    // class body
};
```

---

## 🧪 Simple Example: Class Template with Default Types

```cpp
#include <iostream>
using namespace std;

template <typename T1 = int, typename T2 = float>
class Demo {
public:
    T1 x;
    T2 y;

    Demo(T1 a, T2 b) {
        x = a;
        y = b;
    }

    void show() {
        cout << "x: " << x << ", y: " << y << endl;
    }
};

int main() {
    Demo<> obj1(10, 3.14);          // uses default: int, float
    Demo<double, int> obj2(4.5, 2); // uses: double, int

    obj1.show();  // x: 10, y: 3.14
    obj2.show();  // x: 4.5, y: 2

    return 0;
}
```

---

## 🧾 Output:

```
x: 10, y: 3.14  
x: 4.5, y: 2
```

---

## ✅ Explanation

| Concept                        | Description                             |
| ------------------------------ | --------------------------------------- |
| `template <typename T1 = int>` | Sets default type for `T1`              |
| `Demo<>`                       | Uses `int` and `float` as default types |
| `Demo<double, int>`            | Manually override both types            |

---

## 🧠 Why It’s Useful?

* ✅ Reduces repetition when the most common type is known
* ✅ Makes templates easier to use for beginners
* ✅ Perfect for **default integer containers**, **pairs**, etc.

---

## 🧪 Mini Challenge for You

Create a template like:

```cpp
template <typename A = string, typename B = int>
class PairPrinter {
    A first;
    B second;
public:
    PairPrinter(A f, B s) : first(f), second(s) {}
    void print() {
        cout << first << " - " << second << endl;
    }
};
```

Then try:

```cpp
PairPrinter<> p1("Alice", 30);
PairPrinter<float, float> p2(3.5, 2.5);
```

---
---

# Lec-67

## C++ Function Templates & Function Templates with Parameters:

## 🔷 What is a Function Template?

A **function template** lets you write **one function** that works for **any data type** (int, float, char, etc.).

---

## ✅ 1. Basic Function Template

### 🔧 Syntax:

```cpp
template <typename T>
T functionName(T a, T b) {
    // logic
}
```

* `T` is a placeholder type (can also use `class` instead of `typename`).

---

### 🧪 Simple Example: Find Maximum

```cpp
#include <iostream>
using namespace std;

template <typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    cout << getMax(10, 20) << endl;        // int
    cout << getMax(3.14, 2.71) << endl;    // double
    cout << getMax('a', 'z') << endl;      // char
    return 0;
}
```

---

## 🧾 Output:

```
20  
3.14  
z
```

---

## ✅ 2. Function Template with Multiple Parameters

You can use **more than one type**:

### 🧪 Example: Sum of Different Types

```cpp
#include <iostream>
using namespace std;

template <typename T1, typename T2>
void add(T1 a, T2 b) {
    cout << "Sum is: " << a + b << endl;
}

int main() {
    add(5, 6);           // int + int
    add(2.5, 4);         // double + int
    add(3, 4.7f);        // int + float
    return 0;
}
```

---

## 🧾 Output:

```
Sum is: 11  
Sum is: 6.5  
Sum is: 7.7
```

---

## ✅ Explanation

| Concept                      | Description                                 |
| ---------------------------- | ------------------------------------------- |
| `template <typename T>`      | Generic function for any one type           |
| `template <typename T1, T2>` | Function can handle two **different types** |
| `getMax(a, b)`               | Returns max of both values                  |
| `add(a, b)`                  | Adds mixed types (int, float, etc.)         |

---

## ⚡ Real-World Usage

✅ Makes code **reusable**
✅ Saves time during **contests or interviews**
✅ Allows building **utility functions** like:

* `min()`, `max()`
* `swap()`
* `compare()`
* `abs()`
* `printArray()`

---

## ✅ Bonus Example: Swap Two Values

```cpp
template <typename T>
void mySwap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}
```

Used like:

```cpp
int x = 5, y = 10;
mySwap(x, y);  // Now x = 10, y = 5
```

---

## 📝 Summary Table

| Feature              | Function Template                        |
| -------------------- | ---------------------------------------- |
| Generic for any type | `template<typename T>`                   |
| Multiple types       | `template<typename T1, typename T2>`     |
| Replaces overloads   | One template = many type-specific funcs  |
| Used in STL          | `sort`, `swap`, `max` are template-based |

---
---

# Lec-68

## Member Function Templates & Overloading Template Functions in C++:

## 🔷 1. **Member Function Templates**

> A **member function** inside a class can be a **template**, even if the class itself is not a template.

---

### 🧪 Example: Class with Member Function Template

```cpp
#include <iostream>
using namespace std;

class Printer {
public:
    template <typename T>
    void display(T value) {
        cout << "Value: " << value << endl;
    }
};

int main() {
    Printer p;
    p.display(10);         // int
    p.display(3.14);       // float
    p.display("Hello");    // string
    return 0;
}
```

---

### ✅ Output:

```
Value: 10  
Value: 3.14  
Value: Hello
```

---

## ✅ Explanation

* `template<typename T>` before `display()` makes it a **member function template**
* It allows `display()` to **accept any data type**
* The class `Printer` itself is **not a template**

---

## 🔷 You can also use member templates inside **template classes**

```cpp
template <typename T>
class Container {
public:
    T data;

    Container(T val) : data(val) {}

    template <typename U>
    void show(U extra) {
        cout << "Data: " << data << ", Extra: " << extra << endl;
    }
};
```

Call:

```cpp
Container<int> c(10);
c.show(3.14);  // int + double
```

---

## 🔶 2. **Overloading Template Functions**

> You can **overload a template function** by writing:

* A **template version**
* A **non-template** (normal) version

The compiler picks the **best match**.

---

### 🧪 Example: Template + Non-template Overload

```cpp
#include <iostream>
using namespace std;

template <typename T>
void print(T x) {
    cout << "Template version: " << x << endl;
}

void print(int x) {
    cout << "Non-template version: " << x << endl;
}

int main() {
    print(10);      // Calls non-template (exact match)
    print(3.14);    // Calls template (no exact match for double)
    print("Hi");    // Calls template (string)
    return 0;
}
```

---

### ✅ Output:

```
Non-template version: 10  
Template version: 3.14  
Template version: Hi
```

---

### ✅ How It Works:

| Function Call | Matched Function                          |
| ------------- | ----------------------------------------- |
| `print(10)`   | Exact match: `int` → non-template         |
| `print(3.14)` | No `double` overload → uses template      |
| `print("Hi")` | No `const char*` overload → uses template |

---

### 🎯 You can also overload **with different number of arguments**

```cpp
template <typename T>
void show(T a) {
    cout << "One param: " << a << endl;
}

template <typename T1, typename T2>
void show(T1 a, T2 b) {
    cout << "Two params: " << a << ", " << b << endl;
}
```

---

## 📝 Summary

| Concept                    | Description                                          |
| -------------------------- | ---------------------------------------------------- |
| Member Function Template   | Template functions inside normal or template classes |
| Overloading Template Funcs | Write both template & non-template versions          |
| Compiler Behavior          | Chooses the **most specific match**                  |

---

## ✅ Real Use Cases in CP

* `print()` functions that work for int, double, char, string, etc.
* `compare()`, `swap()`, and `min()` templates with overloads for edge cases
* Member templates for flexible `Graph`, `Stack`, or `Tree` classes

---
--- 

# Lec-69

## The C++ Standard Template Library (STL):

## ✅ What is STL?

> The **Standard Template Library (STL)** is a collection of **template-based classes and functions** for commonly used **data structures and algorithms**.

It provides:

1. ✅ Containers (like `vector`, `set`, `map`)
2. ✅ Algorithms (like `sort()`, `binary_search()`)
3. ✅ Iterators (like `begin()`, `end()`)
4. ✅ Function Objects (like `greater<int>`)

---

## 🧱 1. STL Containers

**Containers** store collections of data.

| Container Type     | Example          | Use Case               |
| ------------------ | ---------------- | ---------------------- |
| Sequence           | `vector`         | Dynamic array          |
|                    | `list`           | Doubly linked list     |
|                    | `deque`          | Double-ended queue     |
| Associative        | `set`            | Unique sorted elements |
|                    | `map`            | Key-value pairs        |
|                    | `multiset`       | Duplicates allowed     |
|                    | `unordered_map`  | Fast hash table        |
| Container Adapters | `stack`          | LIFO stack             |
|                    | `queue`          | FIFO queue             |
|                    | `priority_queue` | Max/min heap           |

---

## 🔧 2. STL Algorithms

**Algorithms** work on containers (via iterators).

| Algorithm         | Use                       |
| ----------------- | ------------------------- |
| `sort()`          | Sort range of elements    |
| `reverse()`       | Reverse elements          |
| `count()`         | Count occurrences         |
| `find()`          | Search for a value        |
| `binary_search()` | Fast lookup (sorted only) |
| `max_element()`   | Find largest element      |

---

## 🧭 3. Iterators

**Iterators** act like smart pointers for STL containers.

### Example:

```cpp
vector<int> v = {1, 2, 3};

for (vector<int>::iterator it = v.begin(); it != v.end(); ++it)
    cout << *it << " ";
```

Or simply use a **range-based loop**:

```cpp
for (int x : v)
    cout << x << " ";
```

---

## 🧠 Benefits of STL

| Benefit           | Description                            |
| ----------------- | -------------------------------------- |
| 📦 Reusability    | Use built-in classes like vector, set  |
| 🚀 Performance    | STL is highly optimized                |
| ⏱️ Time-saving    | No need to implement common structures |
| 🧠 Generic        | Works with any type (`template` based) |
| 🔍 Debug-friendly | Easy to print and test logic           |

---

## 🛠 STL in Competitive Programming

| Task            | STL Tool                 |
| --------------- | ------------------------ |
| Fast input      | `vector`, `cin.tie(0)`   |
| Sorting         | `sort()`                 |
| Frequency count | `map`, `unordered_map`   |
| Priority access | `priority_queue`         |
| Fast lookup     | `set`, `binary_search()` |

---

## 📝 Summary Table

| STL Component | Examples               | Purpose                         |
| ------------- | ---------------------- | ------------------------------- |
| Containers    | `vector`, `set`, `map` | Store and manage data           |
| Algorithms    | `sort()`, `find()`     | Operate on container elements   |
| Iterators     | `begin()`, `end()`     | Traverse containers             |
| Adapters      | `stack`, `queue`       | Provide special container types |

---

## ✅ Practice Ideas

Try using STL to solve:

* ✅ Find duplicates using `map`
* ✅ Sort students by marks using `pair + sort`
* ✅ Implement a simple task scheduler using `priority_queue`

---
---

# Lec-70

## Containers in C++ STL:

## 🔰 What Are Containers?

> A **container** in STL is a **data structure template** that stores **a collection of elements**.
> 🧠 Store, Organize, and Access Data Efficiently

All containers are **template-based** and work with **iterators**.

---

## 🗂️ Types of Containers

STL containers are divided into **3 main categories**:

| Category               | Description                                  | Examples                           |
| ---------------------- | -------------------------------------------- | ---------------------------------- |
| **Sequence**           | Store elements in a linear order             | `vector`, `list`, `deque`          |
| **Associative**        | Store elements using keys or sorting         | `set`, `map`, `multimap`           |
| **Unordered**          | Store elements using hashing (faster lookup) | `unordered_set`, `unordered_map`   |
| **Container Adapters** | Built on top of other containers             | `stack`, `queue`, `priority_queue` |

---

## 🔹 1. Sequence Containers

| Container | Description        | Key Features               |
| --------- | ------------------ | -------------------------- |
| `vector`  | Dynamic array      | Fast access, resizeable    |
| `list`    | Doubly linked list | Fast insertion/deletion    |
| `deque`   | Double-ended queue | Insert/remove at both ends |

🔧 **Use Case**: When order and index-based access are important

---

### ✅ `vector` Example

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    v.push_back(4);  // Add to end

    for (int x : v)
        cout << x << " ";
    return 0;
}
```

---

## 🔹 2. Associative Containers

| Container  | Description                          | Key Feature                 |
| ---------- | ------------------------------------ | --------------------------- |
| `set`      | Unique, sorted elements              | Auto-sorted, no duplicates  |
| `multiset` | Sorted elements (duplicates allowed) | Allows multiple same values |
| `map`      | Key-value pairs (unique keys)        | Sorted by key               |
| `multimap` | Key-value pairs (duplicate keys)     | Allows duplicate keys       |

🔧 **Use Case**: Fast search, sorted data, key-value storage

---

### ✅ `map` Example

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<string, int> age;
    age["Alice"] = 25;
    age["Bob"] = 30;

    cout << "Alice is " << age["Alice"] << " years old.\n";
    return 0;
}
```

---

## 🔹 3. Unordered Containers (Hash-based)

| Container       | Description                | Speed                      |
| --------------- | -------------------------- | -------------------------- |
| `unordered_set` | Unique values (no order)   | 🔥 O(1) avg. insert/search |
| `unordered_map` | Key-value pairs (no order) | 🔥 O(1) avg. insert/search |

🔧 **Use Case**: Fastest lookup, when order doesn’t matter

---

### ✅ `unordered_map` Example

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<int, string> m;
    m[1] = "one";
    m[2] = "two";

    cout << m[2] << endl;  // Output: two
    return 0;
}
```

---

## 🔹 4. Container Adapters

| Adapter          | Based on        | Description               |
| ---------------- | --------------- | ------------------------- |
| `stack`          | `deque`         | LIFO (last-in-first-out)  |
| `queue`          | `deque`         | FIFO (first-in-first-out) |
| `priority_queue` | `vector` (heap) | Max-heap by default       |

🔧 **Use Case**: Specific data access patterns (LIFO, FIFO, Max/Min priority)

---

### ✅ `stack` Example

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    s.push(10);
    s.push(20);
    s.pop();  // Removes 20

    cout << s.top();  // Output: 10
    return 0;
}
```

---

## 📝 Quick Comparison Table

| Container        | Duplicates | Ordered | Fast Access | Use Case                    |
| ---------------- | ---------- | ------- | ----------- | --------------------------- |
| `vector`         | ✅          | ✅       | ✅           | Dynamic arrays              |
| `set`            | ❌          | ✅       | ⚡           | Unique sorted elements      |
| `unordered_map`  | ❌          | ❌       | ⚡⚡          | Fast key-value lookup       |
| `stack`          | ✅          | LIFO    | ✅           | Expression evaluation, undo |
| `priority_queue` | ✅          | Heap    | ✅           | Greedy algorithms, heaps    |

---

## ✅ Summary

* **STL Containers = Prebuilt Data Structures** (powerful + generic)
* Use **`vector`**, **`map`**, **`set`** in 90% of competitive problems
* Combine with **STL Algorithms** (`sort`, `find`, etc.) for max productivity

---
---

# Lec-71

## Vector In C++ STL:

Absolutely! Let's dive deep into **`vector` in C++ STL** — one of the most used and powerful containers in both **competitive programming** and **real-world C++ projects**.

---

# 🔷 `vector` in C++ STL

## 📦 Dynamic Array with Powerful Features

---

## ✅ What is a `vector`?

> A **`vector`** is a **dynamic array** provided by the STL.
> It can grow or shrink in size automatically and supports **random access**, just like a regular array.

### 📚 Header:

```cpp
#include <vector>
```

---

## ✅ Basic Syntax

```cpp
vector<type> name;
```

### Examples:

```cpp
vector<int> v;         // empty vector of integers
vector<char> letters;  // vector of chars
vector<int> nums(5);   // vector with 5 default-initialized ints (0)
vector<int> a = {1, 2, 3}; // initializer list
```

---

## ✅ Common Member Functions

| Function                | Description                               |
| ----------------------- | ----------------------------------------- |
| `v.push_back(x)`        | Add element `x` to the end                |
| `v.pop_back()`          | Remove last element                       |
| `v.size()`              | Number of elements                        |
| `v.clear()`             | Remove all elements                       |
| `v.empty()`             | Check if vector is empty                  |
| `v.front()`             | Access first element                      |
| `v.back()`              | Access last element                       |
| `v[i]` or `at(i)`       | Access i-th element                       |
| `v.begin()` / `v.end()` | Iterators to first and after-last element |

---

## 🧪 Example: Basic Usage

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v;

    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    cout << "Vector elements: ";
    for (int x : v) {
        cout << x << " ";
    }

    cout << "\nSize: " << v.size();       // 3
    cout << "\nFront: " << v.front();     // 10
    cout << "\nBack: " << v.back();       // 30

    v.pop_back();  // removes 30
    cout << "\nAfter pop_back(), size: " << v.size(); // 2

    return 0;
}
```

---

## 🧾 Output:

```
Vector elements: 10 20  
Size: 3  
Front: 10  
Back: 30  
After pop_back(), size: 2
```

---

## 🔄 Iterating Through a Vector

### Method 1: Range-based for loop (C++11+)

```cpp
for (int x : v) {
    cout << x << " ";
}
```

### Method 2: Iterator

```cpp
for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    cout << *it << " ";
}
```

---

## ✅ Initialize with Values

```cpp
vector<int> v(5, 100); // [100, 100, 100, 100, 100]
```

---

## ⚡ Use in Competitive Programming

```cpp
int n;
cin >> n;
vector<int> arr(n);
for (int i = 0; i < n; ++i)
    cin >> arr[i];

sort(arr.begin(), arr.end());  // STL sort
```

---

## 🔥 Key Advantages

| Feature         | Advantage                            |
| --------------- | ------------------------------------ |
| Dynamic Sizing  | No need to define size ahead of time |
| Random Access   | Just like arrays: `v[i]`             |
| STL Integration | Works with `sort()`, `find()`, etc.  |
| Easy to Use     | Cleaner than raw arrays              |

---

## 🧠 Bonus: 2D Vector

```cpp
vector<vector<int>> matrix(3, vector<int>(4, 0)); // 3x4 2D matrix of 0s
```

Access like:

```cpp
matrix[0][1] = 5;
```

---

## 📝 Summary

| Task                 | Vector Code                  |
| -------------------- | ---------------------------- |
| Create vector        | `vector<int> v;`             |
| Add element          | `v.push_back(x);`            |
| Remove element       | `v.pop_back();`              |
| Access element       | `v[i]` or `v.at(i)`          |
| Iterate elements     | `for (int x : v)`            |
| Resize automatically | Handled internally by vector |

---
---

# Lec-72

## List In C++ STL:

Great! Let's dive into the **`list` container in C++ STL** — a powerful tool when you need fast insertion and deletion at both ends or in the middle.

---

# 🔷 `list` in C++ STL

## 📦 Doubly Linked List for Fast Insert/Delete

---

## ✅ What is `list`?

> The **`list`** is a **doubly linked list** container in C++ STL.
> Each element points to both its previous and next element.

### 📚 Header File:

```cpp
#include <list>
```

---

## 🧠 Key Features of `list`

| Feature                 | Description                       |
| ----------------------- | --------------------------------- |
| Doubly linked list      | Two pointers: next and previous   |
| Fast insertion/deletion | Anywhere (beginning, middle, end) |
| No random access        | Can't use `list[i]`               |
| Bidirectional iterators | Can go forward and backward       |

---

## ✅ Syntax

```cpp
list<datatype> list_name;
```

### Example:

```cpp
list<int> myList;
```

---

## 🧪 Basic Example

```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    list<int> l;

    l.push_back(10);   // Add to end
    l.push_front(20);  // Add to front
    l.push_back(30);

    for (int x : l)
        cout << x << " ";  // Output: 20 10 30

    return 0;
}
```

---

## 🔧 Common Member Functions

| Function        | Description                    |
| --------------- | ------------------------------ |
| `push_back(x)`  | Add `x` to end                 |
| `push_front(x)` | Add `x` to front               |
| `pop_back()`    | Remove from end                |
| `pop_front()`   | Remove from front              |
| `insert(it, x)` | Insert before iterator `it`    |
| `erase(it)`     | Erase element at iterator `it` |
| `remove(x)`     | Remove all occurrences of `x`  |
| `sort()`        | Sorts list in ascending order  |
| `reverse()`     | Reverses the list              |
| `clear()`       | Clears all elements            |
| `empty()`       | Returns true if list is empty  |
| `size()`        | Returns number of elements     |

---

## ✅ Example: Insertion, Deletion, Sorting

```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    list<int> l = {5, 1, 3, 2};

    l.sort();         // sorts the list
    l.push_front(0);  // 0 1 2 3 5
    l.reverse();      // 5 3 2 1 0

    l.remove(2);      // removes all 2s

    for (int x : l)
        cout << x << " ";
    return 0;
}
```

---

## 🧾 Output:

```
5 3 1 0
```

---

## ❌ Random Access Is Not Allowed

Unlike `vector`, you **can’t do**:

```cpp
l[2]; // ❌ error
```

Instead, use an **iterator**:

```cpp
list<int>::iterator it = l.begin();
advance(it, 2);  // move to 3rd element
cout << *it;
```

---

## ⚡ Use Cases

* Insertion/deletion in **middle** of the list
* Maintaining **sorted list**
* **Undo/redo** stacks (with bidirectional navigation)
* **Double-ended queues**

---

## ✅ Summary Table

| Feature       | `list`                               |
| ------------- | ------------------------------------ |
| Type          | Doubly linked list                   |
| Random Access | ❌ Not allowed                        |
| Insert/Delete | ✅ Fast at any position               |
| Traversal     | ✅ Forward and backward               |
| Use When      | Frequent insertions/deletions needed |

---

## 🧠 Bonus: Initialization Tricks

```cpp
list<int> a(5, 100);     // {100, 100, 100, 100, 100}
list<int> b = {1, 2, 3}; // initializer list
```

---
---

# Lec-72

## Map In C++ STL:

## ✅ What is a `map`?

> A **`map`** is an associative container that stores **key-value pairs** in **sorted order by key** using a **balanced binary search tree** (typically a Red-Black Tree).
> 📚 Sorted Key-Value Pairs with Fast Lookup

### 📁 Header:

```cpp
#include <map>
```

---

## 📌 Key Properties of `map`

| Feature          | Description                                   |
| ---------------- | --------------------------------------------- |
| Unique keys      | No duplicate keys allowed                     |
| Sorted by key    | Always sorted in ascending order (by default) |
| Fast operations  | `O(log n)` for insert, delete, search         |
| Key-value access | Use `m[key]` to access value                  |

---

## ✅ Basic Syntax

```cpp
map<key_type, value_type> map_name;
```

### Example:

```cpp
map<string, int> age;
```

---

## 🧪 Example: Basic Usage

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<string, int> age;

    age["Alice"] = 25;
    age["Bob"] = 30;
    age["Charlie"] = 28;

    for (auto it : age) {
        cout << it.first << ": " << it.second << endl;
    }

    return 0;
}
```

---

### 🧾 Output:

```
Alice: 25  
Bob: 30  
Charlie: 28
```

🔹 Notice: Output is **sorted by key** (`Alice`, `Bob`, `Charlie`)

---

## 🔧 Common Functions

| Function               | Description                                       |
| ---------------------- | ------------------------------------------------- |
| `m[key]`               | Access/insert value at `key`                      |
| `m.at(key)`            | Access value (throws error if not found)          |
| `m.insert({key, val})` | Insert a key-value pair                           |
| `m.erase(key)`         | Remove key-value by key                           |
| `m.size()`             | Number of elements                                |
| `m.clear()`            | Remove all entries                                |
| `m.empty()`            | Check if map is empty                             |
| `m.count(key)`         | Returns 1 if key exists, else 0                   |
| `m.find(key)`          | Returns iterator to key (or `end()` if not found) |

---

## ✅ Example: Insert, Access, Erase

```cpp
map<int, string> students;

students[101] = "Ravi";
students[105] = "Anjali";
students[102] = "Zara";

cout << students[105] << endl;    // Anjali

students.erase(101);              // Remove Ravi

for (auto p : students)
    cout << p.first << " => " << p.second << endl;
```

---

### 🧾 Output:

```
Anjali  
102 => Zara  
105 => Anjali
```

---

## 🔍 Search with `find()`

```cpp
if (students.find(105) != students.end()) {
    cout << "Found student 105\n";
}
```

---

## 🧠 Use Cases

* Frequency counter (e.g., counting character/word appearances)
* Lookup tables
* Symbol tables (compiler design)
* Associating metadata (like names to scores, IDs to objects)

---

## 🔀 Iteration Methods

### Method 1: Range-based loop

```cpp
for (auto p : m)
    cout << p.first << " => " << p.second;
```

### Method 2: Iterator

```cpp
for (map<string, int>::iterator it = m.begin(); it != m.end(); ++it)
    cout << it->first << ": " << it->second;
```

---

## 🧾 Bonus: Count Frequency of Words

```cpp
#include <map>
#include <string>
#include <iostream>
using namespace std;

int main() {
    map<string, int> freq;
    string words[] = {"apple", "banana", "apple", "orange", "banana"};

    for (string w : words)
        freq[w]++;

    for (auto f : freq)
        cout << f.first << ": " << f.second << endl;
}
```

---

## ✅ Output:

```
apple: 2  
banana: 2  
orange: 1
```

---

## 🔁 Summary Table

| Feature     | `map` STL                                |
| ----------- | ---------------------------------------- |
| Stores      | Key-value pairs                          |
| Order       | Sorted by key (ascending by default)     |
| Duplicates  | ❌ No duplicate keys                      |
| Lookup Time | `O(log n)` (uses balanced BST)           |
| Use Case    | Dictionary, index mapping, frequency map |

---
---

# Lec-74

## Function Objects (Functors) In C++ STL:

## ✅ What is a Function Object / Functor?

> A **Function Object**, or **Functor**, is **any object that can be called like a function** using the `()` operator.

In C++, this is possible by **overloading the `operator()`** in a class or struct.

---

## 🧪 Simple Functor Example

```cpp
#include <iostream>
using namespace std;

class Adder {
public:
    int operator()(int a, int b) {
        return a + b;
    }
};

int main() {
    Adder add;         // Create functor object
    cout << add(3, 4); // Works like a function → Output: 7
    return 0;
}
```

✅ Here, `add(3, 4)` looks like a function call, but it’s calling the object `add` with `()`.

---

## ✅ Why Use Functors?

| Reason                        | Description                                     |
| ----------------------------- | ----------------------------------------------- |
| Can store state               | Unlike functions, functors can hold member data |
| Used with STL algorithms      | `sort()`, `for_each()`, etc.                    |
| Can replace function pointers | More flexible and object-oriented               |
| Cleaner code for custom logic | e.g., sorting by custom rules                   |

---

## 🔄 Built-in Function Objects in STL

C++ provides built-in functors in `<functional>` header:

| Functor         | Operation         |
| --------------- | ----------------- |
| `plus<T>`       | Adds two values   |
| `minus<T>`      | Subtracts         |
| `multiplies<T>` | Multiplies        |
| `divides<T>`    | Division          |
| `greater<T>`    | Checks if greater |
| `less<T>`       | Checks if smaller |

---

### ✅ Example: `greater<int>` in `sort()`

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {3, 1, 4, 2};

    sort(v.begin(), v.end(), greater<int>());  // Descending order

    for (int x : v)
        cout << x << " ";
    return 0;
}
```

🧾 Output:

```
4 3 2 1
```

---

## 🧪 Custom Functor with `sort()`

### Sort by absolute value

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct AbsSort {
    bool operator()(int a, int b) {
        return abs(a) < abs(b);
    }
};

int main() {
    vector<int> v = {3, -7, 2, -1};

    sort(v.begin(), v.end(), AbsSort());

    for (int x : v)
        cout << x << " ";
    return 0;
}
```

🧾 Output:

```
-1 2 3 -7
```

---

## 🛠 Use with `for_each()`

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Printer {
    void operator()(int x) {
        cout << x << " ";
    }
};

int main() {
    vector<int> v = {1, 2, 3, 4};
    for_each(v.begin(), v.end(), Printer());
    return 0;
}
```

---

## 🧠 Real Uses of Functors

* Custom sort logic
* Custom comparison in `priority_queue`, `set`, etc.
* Using stateful objects in algorithms (e.g., counting, summing)

---

## ✅ Summary

| Feature           | Explanation                          |
| ----------------- | ------------------------------------ |
| Functor           | Object with overloaded `()` operator |
| Built-in functors | `greater<>`, `less<>`, etc.          |
| Used in STL       | `sort()`, `for_each()`, `find_if()`  |
| Custom comparison | Replace third argument in `sort()`   |

---














