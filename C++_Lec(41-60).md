# Lec-41

## Multiple Inheritance Deep Dive with Code Example in C++:

## 🔷 What is Multiple Inheritance?

> 📌 In **multiple inheritance**, a class (child/derived) **inherits from more than one base class**.

This allows a class to **combine functionalities** from multiple parent classes.

---

### 🧱 Structure:

```
       A       B
        \     /
         \   /
          \ /
           C
```

Where:

* `A` and `B` are **base classes**
* `C` is a **derived class** that inherits from both

---

## ✅ Real-Life Analogy:

> Imagine a `Scanner` class and a `Printer` class.
> You can combine both into a `Copier` class using multiple inheritance.

---

## 🔧 Syntax:

```cpp
class A {
    // Base class A
};

class B {
    // Base class B
};

class C : public A, public B {
    // Derived class from A and B
};
```

---

## ✅ Basic Code Example

```cpp
#include <iostream>
using namespace std;

class Engine {
public:
    void startEngine() {
        cout << "Engine started." << endl;
    }
};

class Wheels {
public:
    void rotateWheels() {
        cout << "Wheels are rotating." << endl;
    }
};

class Car : public Engine, public Wheels {
public:
    void drive() {
        cout << "Car is driving." << endl;
    }
};

int main() {
    Car myCar;
    myCar.startEngine();     // from Engine
    myCar.rotateWheels();    // from Wheels
    myCar.drive();           // from Car
    return 0;
}
```

---

🧾 **Output:**

```
Engine started.  
Wheels are rotating.  
Car is driving.
```

✅ `Car` inherits from **both** `Engine` and `Wheels`.

---

## 🧠 Key Points

| Feature                | Behavior                                    |
| ---------------------- | ------------------------------------------- |
| Number of base classes | 2 or more                                   |
| Reusability            | ✅ High                                      |
| Risk of ambiguity      | ⚠️ Yes (same function in both base classes) |
| Constructor call order | In order of inheritance declaration         |

---

## ⚠️ **Ambiguity Problem in Multiple Inheritance**

### 💥 Problem:

```cpp
class A {
public:
    void show() {
        cout << "Show from A" << endl;
    }
};

class B {
public:
    void show() {
        cout << "Show from B" << endl;
    }
};

class C : public A, public B {
    // inherits show() from both A and B
};

int main() {
    C obj;
    // obj.show(); ❌ ERROR: Ambiguous!
}
```

---

### ✅ Solution: **Scope Resolution Operator**

```cpp
int main() {
    C obj;
    obj.A::show();  // Show from A
    obj.B::show();  // Show from B
}
```

---

## ✅ Constructor Call Order in Multiple Inheritance

```cpp
class A {
public:
    A() {
        cout << "Constructor A\n";
    }
};

class B {
public:
    B() {
        cout << "Constructor B\n";
    }
};

class C : public A, public B {
public:
    C() {
        cout << "Constructor C\n";
    }
};

int main() {
    C obj;
    return 0;
}
```

🧾 Output:

```
Constructor A  
Constructor B  
Constructor C
```

✅ Constructors are called in the order of inheritance:

```cpp
class C : public A, public B { ... };
```

---

## ✅ Real-Time Use Case Example

### 🏫 Example: `Person` + `Department` → `Professor`

```cpp
class Person {
protected:
    string name;

public:
    void setName(string n) {
        name = n;
    }
};

class Department {
protected:
    string dept;

public:
    void setDept(string d) {
        dept = d;
    }
};

class Professor : public Person, public Department {
public:
    void display() {
        cout << "Professor " << name << " belongs to " << dept << " department.\n";
    }
};

int main() {
    Professor p;
    p.setName("Gajanan");
    p.setDept("Computer Science");
    p.display();
    return 0;
}
```

🧾 Output:

```
Professor Gajanan belongs to Computer Science department.
```

---

## ✅ Summary Table

| Feature                | Description                                   |
| ---------------------- | --------------------------------------------- |
| Definition             | Class inherits from 2+ base classes           |
| Risk                   | Ambiguity if same method exists in both bases |
| Access                 | Inherited members depend on visibility mode   |
| Constructor Order      | Follows order in declaration                  |
| Solution for Ambiguity | Scope resolution operator                     |

---
---
# Lec-42

## Exercise on C++ Inheritance:

# 🚗 Vehicle System – All Inheritance Types in C++

---

### 👇 Classes We'll Use:

* `Vehicle` – base class
* `Car`, `Bike` – derived classes
* `ElectricCar` – derived from `Car`
* `FlyingCar` – inherits from both `Car` and `Aircraft`
* `Truck` – also inherits from `Vehicle`

---

## ✅ 1. Single Inheritance

> `Car` inherits from `Vehicle`

```cpp
class Vehicle {
public:
    void move() {
        cout << "Moving on road..." << endl;
    }
};

class Car : public Vehicle {
public:
    void type() {
        cout << "This is a Car." << endl;
    }
};
```

---

## ✅ 2. Multilevel Inheritance

> `ElectricCar` → `Car` → `Vehicle`

```cpp
class ElectricCar : public Car {
public:
    void battery() {
        cout << "Runs on electricity." << endl;
    }
};
```

---

## ✅ 3. Multiple Inheritance

> `FlyingCar` inherits from both `Car` and `Aircraft`

```cpp
class Aircraft {
public:
    void fly() {
        cout << "Flying in air..." << endl;
    }
};

class FlyingCar : public Car, public Aircraft {
public:
    void hybrid() {
        cout << "I am a Flying Car." << endl;
    }
};
```

---

## ✅ 4. Hierarchical Inheritance

> Both `Car` and `Truck` inherit from `Vehicle`

```cpp
class Truck : public Vehicle {
public:
    void load() {
        cout << "Carrying goods." << endl;
    }
};
```

---

## ✅ 5. Hybrid Inheritance

> Combination of Hierarchical + Multiple
> For example, `HybridVehicle` inherits from `ElectricCar` and `Truck`

```cpp
class HybridVehicle : public ElectricCar, public Truck {
public:
    void hybridType() {
        cout << "I can carry goods and run on battery!" << endl;
    }
};
```

---

## 🧾 Full Program: All Inheritance Types Together

```cpp
#include <iostream>
using namespace std;

// Base class
class Vehicle {
public:
    void move() {
        cout << "Moving on road..." << endl;
    }
};

// Single & Multilevel
class Car : public Vehicle {
public:
    void type() {
        cout << "This is a Car." << endl;
    }
};

class ElectricCar : public Car {
public:
    void battery() {
        cout << "Runs on electricity." << endl;
    }
};

// Independent base for Multiple
class Aircraft {
public:
    void fly() {
        cout << "Flying in air..." << endl;
    }
};

// Multiple Inheritance
class FlyingCar : public Car, public Aircraft {
public:
    void hybrid() {
        cout << "I am a Flying Car." << endl;
    }
};

// Hierarchical
class Truck : public Vehicle {
public:
    void load() {
        cout << "Carrying goods." << endl;
    }
};

// Hybrid Inheritance
class HybridVehicle : public ElectricCar, public Truck {
public:
    void hybridType() {
        cout << "I can carry goods and run on battery!" << endl;
    }
};

int main() {
    cout << "🔹 Single Inheritance:" << endl;
    Car c;
    c.move();
    c.type();

    cout << "\n🔹 Multilevel Inheritance:" << endl;
    ElectricCar ec;
    ec.move();
    ec.type();
    ec.battery();

    cout << "\n🔹 Multiple Inheritance:" << endl;
    FlyingCar fc;
    fc.type();
    fc.fly();
    fc.hybrid();

    cout << "\n🔹 Hierarchical Inheritance:" << endl;
    Truck t;
    t.move();
    t.load();

    cout << "\n🔹 Hybrid Inheritance:" << endl;
    HybridVehicle hv;
    hv.ElectricCar::move();  // resolve ambiguity from multiple Vehicle inheritance
    hv.battery();
    hv.load();
    hv.hybridType();

    return 0;
}
```

---

### 🧾 Output:

```
🔹 Single Inheritance:
Moving on road...
This is a Car.

🔹 Multilevel Inheritance:
Moving on road...
This is a Car.
Runs on electricity.

🔹 Multiple Inheritance:
This is a Car.
Flying in air...
I am a Flying Car.

🔹 Hierarchical Inheritance:
Moving on road...
Carrying goods.

🔹 Hybrid Inheritance:
Moving on road...
Runs on electricity.
Carrying goods.
I can carry goods and run on battery!
```

---

## ✅ Summary Table

| Inheritance Type | Example Used                             |
| ---------------- | ---------------------------------------- |
| Single           | `Car` ← `Vehicle`                        |
| Multilevel       | `ElectricCar` ← `Car` ← `Vehicle`        |
| Multiple         | `FlyingCar` ← `Car`, `Aircraft`          |
| Hierarchical     | `Car`, `Truck` ← `Vehicle`               |
| Hybrid           | `HybridVehicle` ← `ElectricCar`, `Truck` |

---
---

# Lec -43 //IMP

## Ambiguity Resolution in Inheritance in C++:

## ✅ What is Ambiguity?

> 📌 **Ambiguity occurs when two or more base classes have members with the same name**, and a derived class inherits from them.

Then, the compiler doesn't know **which one** to use — **this causes an error** unless you resolve it.

---

### 🧠 Imagine This:

```cpp
class A {
public:
    void show() { cout << "A" << endl; }
};

class B {
public:
    void show() { cout << "B" << endl; }
};

class C : public A, public B {};

int main() {
    C obj;
    obj.show();  // ❌ Error: Ambiguity!
}
```

🛑 The compiler says:

> *"request for member ‘show’ is ambiguous..."*

Because both `A` and `B` have a `show()` function.

---

## ✅ How to Resolve It?

### 👉 Use **Scope Resolution Operator**:

```cpp
int main() {
    C obj;
    obj.A::show();  // ✅ Calls A’s show()
    obj.B::show();  // ✅ Calls B’s show()
}
```

---

## ✅ Ambiguity with Data Members

```cpp
class A {
public:
    int value = 10;
};

class B {
public:
    int value = 20;
};

class C : public A, public B {
public:
    void showValue() {
        // cout << value; ❌ Ambiguity
        cout << "A's value: " << A::value << endl;
        cout << "B's value: " << B::value << endl;
    }
};
```

---

## ✅ Ambiguity in Diamond Problem

### 🔷 The Diamond Problem

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : public A {};
class C : public A {};
class D : public B, public C {};  // 💎 Diamond shape
```

Now:

```cpp
int main() {
    D obj;
    obj.display();  // ❌ Ambiguity: inherited twice from A
}
```

---

### ✅ Solution: Use **`virtual` inheritance**

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};

int main() {
    D obj;
    obj.display();  // ✅ Now unambiguous
}
```

🎯 **Virtual inheritance** ensures that only **one copy of `A`** exists in `D`.

---

## ✅ Summary Table

| Situation                | Ambiguity Reason                  | Solution                      |
| ------------------------ | --------------------------------- | ----------------------------- |
| Same function in 2 bases | Function conflict                 | Scope resolution (`A::fun()`) |
| Same variable in 2 bases | Variable conflict                 | Scope resolution (`B::var`)   |
| Diamond structure        | Multiple inheritance of same base | Use `virtual` keyword         |

---

## ✅ Real-World Example:

```cpp
class Printer {
public:
    void info() { cout << "Printer Info" << endl; }
};

class Scanner {
public:
    void info() { cout << "Scanner Info" << endl; }
};

class Copier : public Printer, public Scanner {
public:
    void showInfo() {
        Printer::info();  // resolve ambiguity
        Scanner::info();
    }
};
```

---

## ✅ Conclusion:

* Ambiguity is common in **multiple** or **hybrid** inheritance.
* Use:

  * ✅ **Scope resolution operator** for functions/variables
  * ✅ **Virtual inheritance** to fix **diamond problem**

---
---

# Lec-44 & 45

## Virtual Base Class in C++ & Code Example Demonstrating Virtual Base Class in C++:

Excellent! Let’s explore a powerful concept in C++ inheritance:

# 🎯 **Virtual Base Class**

---

## ✅ What is a Virtual Base Class?

> 📌 A **virtual base class** is used to **prevent multiple “instances”** of a base class when it's **inherited more than once indirectly** — especially in **diamond inheritance problems**.

---

### 🔺 The Diamond Problem

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : public A {};
class C : public A {};
class D : public B, public C {};  // D has 2 copies of A!
```

In this structure:

```
      A
     / \
    B   C
     \ /
      D
```

Now calling:

```cpp
D obj;
obj.display();  // ❌ Ambiguous: 2 copies of A::display()
```

---

## ✅ Solution: Use **virtual inheritance**

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};
```

Now:

```cpp
int main() {
    D obj;
    obj.display();  // ✅ Only 1 copy of A — no ambiguity
    return 0;
}
```

✅ This is how **virtual base classes eliminate ambiguity** in the diamond problem.

---

## 🔍 How It Works:

* When you use `virtual` in inheritance:

  * C++ compiler ensures **only one shared instance** of the base class is used.
  * That shared instance is used by all intermediate and derived classes.

---

## 🧠 Real-Life Analogy:

> You attend two workshops — both provide the **same certificate**.
> Without `virtual`, you receive **two duplicate certificates** (confusing!).
> With `virtual`, you get **just one shared certificate** — clear and correct.

---

## ✅ Full Example with Virtual Base

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    void identity() {
        cout << "I am a Person\n";
    }
};

class Employee : virtual public Person {
public:
    void empDetails() {
        cout << "Employee of Company\n";
    }
};

class Student : virtual public Person {
public:
    void study() {
        cout << "Currently studying\n";
    }
};

class Intern : public Employee, public Student {
public:
    void work() {
        cout << "Internship ongoing\n";
    }
};

int main() {
    Intern i;
    i.identity();     // ✅ no ambiguity
    i.empDetails();
    i.study();
    i.work();
    return 0;
}
```

🧾 Output:

```
I am a Person  
Employee of Company  
Currently studying  
Internship ongoing
```

---

## 🧾 Summary Table

| Feature                   | Description                                           |
| ------------------------- | ----------------------------------------------------- |
| Use                       | Resolve ambiguity in **diamond inheritance**          |
| Keyword                   | `virtual` before `public` (or `private`)              |
| Effect                    | Only **1 shared copy** of base class in derived       |
| Common Error Avoided      | "ambiguous base class" or duplicate constructor calls |
| C++ Compiler Optimization | Ensures clean and unambiguous object layout           |

---

## ❗ Key Notes

* Use `virtual` at the **first level** of inheritance (e.g., in `B` and `C`, not in `D`)
* You can combine `virtual` with any visibility mode:

  * `virtual public`
  * `virtual protected`
  * `virtual private`

---
---

# Lec-46

## 



