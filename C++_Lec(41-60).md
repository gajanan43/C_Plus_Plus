# Lec-41

## Multiple Inheritance Deep Dive with Code Example in C++:

## ğŸ”· What is Multiple Inheritance?

> ğŸ“Œ In **multiple inheritance**, a class (child/derived) **inherits from more than one base class**.

This allows a class to **combine functionalities** from multiple parent classes.

---

### ğŸ§± Structure:

```
       A       B
        \     /
         \   /
          \ /
           C
```

Where:

* `A` and `B` are **base classes**
* `C` is a **derived class** that inherits from both

---

## âœ… Real-Life Analogy:

> Imagine a `Scanner` class and a `Printer` class.
> You can combine both into a `Copier` class using multiple inheritance.

---

## ğŸ”§ Syntax:

```cpp
class A {
    // Base class A
};

class B {
    // Base class B
};

class C : public A, public B {
    // Derived class from A and B
};
```

---

## âœ… Basic Code Example

```cpp
#include <iostream>
using namespace std;

class Engine {
public:
    void startEngine() {
        cout << "Engine started." << endl;
    }
};

class Wheels {
public:
    void rotateWheels() {
        cout << "Wheels are rotating." << endl;
    }
};

class Car : public Engine, public Wheels {
public:
    void drive() {
        cout << "Car is driving." << endl;
    }
};

int main() {
    Car myCar;
    myCar.startEngine();     // from Engine
    myCar.rotateWheels();    // from Wheels
    myCar.drive();           // from Car
    return 0;
}
```

---

ğŸ§¾ **Output:**

```
Engine started.  
Wheels are rotating.  
Car is driving.
```

âœ… `Car` inherits from **both** `Engine` and `Wheels`.

---

## ğŸ§  Key Points

| Feature                | Behavior                                    |
| ---------------------- | ------------------------------------------- |
| Number of base classes | 2 or more                                   |
| Reusability            | âœ… High                                      |
| Risk of ambiguity      | âš ï¸ Yes (same function in both base classes) |
| Constructor call order | In order of inheritance declaration         |

---

## âš ï¸ **Ambiguity Problem in Multiple Inheritance**

### ğŸ’¥ Problem:

```cpp
class A {
public:
    void show() {
        cout << "Show from A" << endl;
    }
};

class B {
public:
    void show() {
        cout << "Show from B" << endl;
    }
};

class C : public A, public B {
    // inherits show() from both A and B
};

int main() {
    C obj;
    // obj.show(); âŒ ERROR: Ambiguous!
}
```

---

### âœ… Solution: **Scope Resolution Operator**

```cpp
int main() {
    C obj;
    obj.A::show();  // Show from A
    obj.B::show();  // Show from B
}
```

---

## âœ… Constructor Call Order in Multiple Inheritance

```cpp
class A {
public:
    A() {
        cout << "Constructor A\n";
    }
};

class B {
public:
    B() {
        cout << "Constructor B\n";
    }
};

class C : public A, public B {
public:
    C() {
        cout << "Constructor C\n";
    }
};

int main() {
    C obj;
    return 0;
}
```

ğŸ§¾ Output:

```
Constructor A  
Constructor B  
Constructor C
```

âœ… Constructors are called in the order of inheritance:

```cpp
class C : public A, public B { ... };
```

---

## âœ… Real-Time Use Case Example

### ğŸ« Example: `Person` + `Department` â†’ `Professor`

```cpp
class Person {
protected:
    string name;

public:
    void setName(string n) {
        name = n;
    }
};

class Department {
protected:
    string dept;

public:
    void setDept(string d) {
        dept = d;
    }
};

class Professor : public Person, public Department {
public:
    void display() {
        cout << "Professor " << name << " belongs to " << dept << " department.\n";
    }
};

int main() {
    Professor p;
    p.setName("Gajanan");
    p.setDept("Computer Science");
    p.display();
    return 0;
}
```

ğŸ§¾ Output:

```
Professor Gajanan belongs to Computer Science department.
```

---

## âœ… Summary Table

| Feature                | Description                                   |
| ---------------------- | --------------------------------------------- |
| Definition             | Class inherits from 2+ base classes           |
| Risk                   | Ambiguity if same method exists in both bases |
| Access                 | Inherited members depend on visibility mode   |
| Constructor Order      | Follows order in declaration                  |
| Solution for Ambiguity | Scope resolution operator                     |

---
---
# Lec-42

## Exercise on C++ Inheritance:

# ğŸš— Vehicle System â€“ All Inheritance Types in C++

---

### ğŸ‘‡ Classes We'll Use:

* `Vehicle` â€“ base class
* `Car`, `Bike` â€“ derived classes
* `ElectricCar` â€“ derived from `Car`
* `FlyingCar` â€“ inherits from both `Car` and `Aircraft`
* `Truck` â€“ also inherits from `Vehicle`

---

## âœ… 1. Single Inheritance

> `Car` inherits from `Vehicle`

```cpp
class Vehicle {
public:
    void move() {
        cout << "Moving on road..." << endl;
    }
};

class Car : public Vehicle {
public:
    void type() {
        cout << "This is a Car." << endl;
    }
};
```

---

## âœ… 2. Multilevel Inheritance

> `ElectricCar` â†’ `Car` â†’ `Vehicle`

```cpp
class ElectricCar : public Car {
public:
    void battery() {
        cout << "Runs on electricity." << endl;
    }
};
```

---

## âœ… 3. Multiple Inheritance

> `FlyingCar` inherits from both `Car` and `Aircraft`

```cpp
class Aircraft {
public:
    void fly() {
        cout << "Flying in air..." << endl;
    }
};

class FlyingCar : public Car, public Aircraft {
public:
    void hybrid() {
        cout << "I am a Flying Car." << endl;
    }
};
```

---

## âœ… 4. Hierarchical Inheritance

> Both `Car` and `Truck` inherit from `Vehicle`

```cpp
class Truck : public Vehicle {
public:
    void load() {
        cout << "Carrying goods." << endl;
    }
};
```

---

## âœ… 5. Hybrid Inheritance

> Combination of Hierarchical + Multiple
> For example, `HybridVehicle` inherits from `ElectricCar` and `Truck`

```cpp
class HybridVehicle : public ElectricCar, public Truck {
public:
    void hybridType() {
        cout << "I can carry goods and run on battery!" << endl;
    }
};
```

---

## ğŸ§¾ Full Program: All Inheritance Types Together

```cpp
#include <iostream>
using namespace std;

// Base class
class Vehicle {
public:
    void move() {
        cout << "Moving on road..." << endl;
    }
};

// Single & Multilevel
class Car : public Vehicle {
public:
    void type() {
        cout << "This is a Car." << endl;
    }
};

class ElectricCar : public Car {
public:
    void battery() {
        cout << "Runs on electricity." << endl;
    }
};

// Independent base for Multiple
class Aircraft {
public:
    void fly() {
        cout << "Flying in air..." << endl;
    }
};

// Multiple Inheritance
class FlyingCar : public Car, public Aircraft {
public:
    void hybrid() {
        cout << "I am a Flying Car." << endl;
    }
};

// Hierarchical
class Truck : public Vehicle {
public:
    void load() {
        cout << "Carrying goods." << endl;
    }
};

// Hybrid Inheritance
class HybridVehicle : public ElectricCar, public Truck {
public:
    void hybridType() {
        cout << "I can carry goods and run on battery!" << endl;
    }
};

int main() {
    cout << "ğŸ”¹ Single Inheritance:" << endl;
    Car c;
    c.move();
    c.type();

    cout << "\nğŸ”¹ Multilevel Inheritance:" << endl;
    ElectricCar ec;
    ec.move();
    ec.type();
    ec.battery();

    cout << "\nğŸ”¹ Multiple Inheritance:" << endl;
    FlyingCar fc;
    fc.type();
    fc.fly();
    fc.hybrid();

    cout << "\nğŸ”¹ Hierarchical Inheritance:" << endl;
    Truck t;
    t.move();
    t.load();

    cout << "\nğŸ”¹ Hybrid Inheritance:" << endl;
    HybridVehicle hv;
    hv.ElectricCar::move();  // resolve ambiguity from multiple Vehicle inheritance
    hv.battery();
    hv.load();
    hv.hybridType();

    return 0;
}
```

---

### ğŸ§¾ Output:

```
ğŸ”¹ Single Inheritance:
Moving on road...
This is a Car.

ğŸ”¹ Multilevel Inheritance:
Moving on road...
This is a Car.
Runs on electricity.

ğŸ”¹ Multiple Inheritance:
This is a Car.
Flying in air...
I am a Flying Car.

ğŸ”¹ Hierarchical Inheritance:
Moving on road...
Carrying goods.

ğŸ”¹ Hybrid Inheritance:
Moving on road...
Runs on electricity.
Carrying goods.
I can carry goods and run on battery!
```

---

## âœ… Summary Table

| Inheritance Type | Example Used                             |
| ---------------- | ---------------------------------------- |
| Single           | `Car` â† `Vehicle`                        |
| Multilevel       | `ElectricCar` â† `Car` â† `Vehicle`        |
| Multiple         | `FlyingCar` â† `Car`, `Aircraft`          |
| Hierarchical     | `Car`, `Truck` â† `Vehicle`               |
| Hybrid           | `HybridVehicle` â† `ElectricCar`, `Truck` |

---
---

# Lec -43 //IMP

## Ambiguity Resolution in Inheritance in C++:

## âœ… What is Ambiguity?

> ğŸ“Œ **Ambiguity occurs when two or more base classes have members with the same name**, and a derived class inherits from them.

Then, the compiler doesn't know **which one** to use â€” **this causes an error** unless you resolve it.

---

### ğŸ§  Imagine This:

```cpp
class A {
public:
    void show() { cout << "A" << endl; }
};

class B {
public:
    void show() { cout << "B" << endl; }
};

class C : public A, public B {};

int main() {
    C obj;
    obj.show();  // âŒ Error: Ambiguity!
}
```

ğŸ›‘ The compiler says:

> *"request for member â€˜showâ€™ is ambiguous..."*

Because both `A` and `B` have a `show()` function.

---

## âœ… How to Resolve It?

### ğŸ‘‰ Use **Scope Resolution Operator**:

```cpp
int main() {
    C obj;
    obj.A::show();  // âœ… Calls Aâ€™s show()
    obj.B::show();  // âœ… Calls Bâ€™s show()
}
```

---

## âœ… Ambiguity with Data Members

```cpp
class A {
public:
    int value = 10;
};

class B {
public:
    int value = 20;
};

class C : public A, public B {
public:
    void showValue() {
        // cout << value; âŒ Ambiguity
        cout << "A's value: " << A::value << endl;
        cout << "B's value: " << B::value << endl;
    }
};
```

---

## âœ… Ambiguity in Diamond Problem

### ğŸ”· The Diamond Problem

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : public A {};
class C : public A {};
class D : public B, public C {};  // ğŸ’ Diamond shape
```

Now:

```cpp
int main() {
    D obj;
    obj.display();  // âŒ Ambiguity: inherited twice from A
}
```

---

### âœ… Solution: Use **`virtual` inheritance**

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};

int main() {
    D obj;
    obj.display();  // âœ… Now unambiguous
}
```

ğŸ¯ **Virtual inheritance** ensures that only **one copy of `A`** exists in `D`.

---

## âœ… Summary Table

| Situation                | Ambiguity Reason                  | Solution                      |
| ------------------------ | --------------------------------- | ----------------------------- |
| Same function in 2 bases | Function conflict                 | Scope resolution (`A::fun()`) |
| Same variable in 2 bases | Variable conflict                 | Scope resolution (`B::var`)   |
| Diamond structure        | Multiple inheritance of same base | Use `virtual` keyword         |

---

## âœ… Real-World Example:

```cpp
class Printer {
public:
    void info() { cout << "Printer Info" << endl; }
};

class Scanner {
public:
    void info() { cout << "Scanner Info" << endl; }
};

class Copier : public Printer, public Scanner {
public:
    void showInfo() {
        Printer::info();  // resolve ambiguity
        Scanner::info();
    }
};
```

---

## âœ… Conclusion:

* Ambiguity is common in **multiple** or **hybrid** inheritance.
* Use:

  * âœ… **Scope resolution operator** for functions/variables
  * âœ… **Virtual inheritance** to fix **diamond problem**

---
---

# Lec-44 & 45

## Virtual Base Class in C++ & Code Example Demonstrating Virtual Base Class in C++:

Excellent! Letâ€™s explore a powerful concept in C++ inheritance:

# ğŸ¯ **Virtual Base Class**

---

## âœ… What is a Virtual Base Class?

> ğŸ“Œ A **virtual base class** is used to **prevent multiple â€œinstancesâ€** of a base class when it's **inherited more than once indirectly** â€” especially in **diamond inheritance problems**.

---

### ğŸ”º The Diamond Problem

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : public A {};
class C : public A {};
class D : public B, public C {};  // D has 2 copies of A!
```

In this structure:

```
      A
     / \
    B   C
     \ /
      D
```

Now calling:

```cpp
D obj;
obj.display();  // âŒ Ambiguous: 2 copies of A::display()
```

---

## âœ… Solution: Use **virtual inheritance**

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};
```

Now:

```cpp
int main() {
    D obj;
    obj.display();  // âœ… Only 1 copy of A â€” no ambiguity
    return 0;
}
```

âœ… This is how **virtual base classes eliminate ambiguity** in the diamond problem.

---

## ğŸ” How It Works:

* When you use `virtual` in inheritance:

  * C++ compiler ensures **only one shared instance** of the base class is used.
  * That shared instance is used by all intermediate and derived classes.

---

## ğŸ§  Real-Life Analogy:

> You attend two workshops â€” both provide the **same certificate**.
> Without `virtual`, you receive **two duplicate certificates** (confusing!).
> With `virtual`, you get **just one shared certificate** â€” clear and correct.

---

## âœ… Full Example with Virtual Base

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    void identity() {
        cout << "I am a Person\n";
    }
};

class Employee : virtual public Person {
public:
    void empDetails() {
        cout << "Employee of Company\n";
    }
};

class Student : virtual public Person {
public:
    void study() {
        cout << "Currently studying\n";
    }
};

class Intern : public Employee, public Student {
public:
    void work() {
        cout << "Internship ongoing\n";
    }
};

int main() {
    Intern i;
    i.identity();     // âœ… no ambiguity
    i.empDetails();
    i.study();
    i.work();
    return 0;
}
```

ğŸ§¾ Output:

```
I am a Person  
Employee of Company  
Currently studying  
Internship ongoing
```

---

## ğŸ§¾ Summary Table

| Feature                   | Description                                           |
| ------------------------- | ----------------------------------------------------- |
| Use                       | Resolve ambiguity in **diamond inheritance**          |
| Keyword                   | `virtual` before `public` (or `private`)              |
| Effect                    | Only **1 shared copy** of base class in derived       |
| Common Error Avoided      | "ambiguous base class" or duplicate constructor calls |
| C++ Compiler Optimization | Ensures clean and unambiguous object layout           |

---

## â— Key Notes

* Use `virtual` at the **first level** of inheritance (e.g., in `B` and `C`, not in `D`)
* You can combine `virtual` with any visibility mode:

  * `virtual public`
  * `virtual protected`
  * `virtual private`

---
---

# Lec-46

## 



