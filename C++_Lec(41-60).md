# Lec-41

## Multiple Inheritance Deep Dive with Code Example in C++:

## 🔷 What is Multiple Inheritance?

> 📌 In **multiple inheritance**, a class (child/derived) **inherits from more than one base class**.

This allows a class to **combine functionalities** from multiple parent classes.

---

### 🧱 Structure:

```
       A       B
        \     /
         \   /
          \ /
           C
```

Where:

* `A` and `B` are **base classes**
* `C` is a **derived class** that inherits from both

---

## ✅ Real-Life Analogy:

> Imagine a `Scanner` class and a `Printer` class.
> You can combine both into a `Copier` class using multiple inheritance.

---

## 🔧 Syntax:

```cpp
class A {
    // Base class A
};

class B {
    // Base class B
};

class C : public A, public B {
    // Derived class from A and B
};
```

---

## ✅ Basic Code Example

```cpp
#include <iostream>
using namespace std;

class Engine {
public:
    void startEngine() {
        cout << "Engine started." << endl;
    }
};

class Wheels {
public:
    void rotateWheels() {
        cout << "Wheels are rotating." << endl;
    }
};

class Car : public Engine, public Wheels {
public:
    void drive() {
        cout << "Car is driving." << endl;
    }
};

int main() {
    Car myCar;
    myCar.startEngine();     // from Engine
    myCar.rotateWheels();    // from Wheels
    myCar.drive();           // from Car
    return 0;
}
```

---

🧾 **Output:**

```
Engine started.  
Wheels are rotating.  
Car is driving.
```

✅ `Car` inherits from **both** `Engine` and `Wheels`.

---

## 🧠 Key Points

| Feature                | Behavior                                    |
| ---------------------- | ------------------------------------------- |
| Number of base classes | 2 or more                                   |
| Reusability            | ✅ High                                      |
| Risk of ambiguity      | ⚠️ Yes (same function in both base classes) |
| Constructor call order | In order of inheritance declaration         |

---

## ⚠️ **Ambiguity Problem in Multiple Inheritance**

### 💥 Problem:

```cpp
class A {
public:
    void show() {
        cout << "Show from A" << endl;
    }
};

class B {
public:
    void show() {
        cout << "Show from B" << endl;
    }
};

class C : public A, public B {
    // inherits show() from both A and B
};

int main() {
    C obj;
    // obj.show(); ❌ ERROR: Ambiguous!
}
```

---

### ✅ Solution: **Scope Resolution Operator**

```cpp
int main() {
    C obj;
    obj.A::show();  // Show from A
    obj.B::show();  // Show from B
}
```

---

## ✅ Constructor Call Order in Multiple Inheritance

```cpp
class A {
public:
    A() {
        cout << "Constructor A\n";
    }
};

class B {
public:
    B() {
        cout << "Constructor B\n";
    }
};

class C : public A, public B {
public:
    C() {
        cout << "Constructor C\n";
    }
};

int main() {
    C obj;
    return 0;
}
```

🧾 Output:

```
Constructor A  
Constructor B  
Constructor C
```

✅ Constructors are called in the order of inheritance:

```cpp
class C : public A, public B { ... };
```

---

## ✅ Real-Time Use Case Example

### 🏫 Example: `Person` + `Department` → `Professor`

```cpp
class Person {
protected:
    string name;

public:
    void setName(string n) {
        name = n;
    }
};

class Department {
protected:
    string dept;

public:
    void setDept(string d) {
        dept = d;
    }
};

class Professor : public Person, public Department {
public:
    void display() {
        cout << "Professor " << name << " belongs to " << dept << " department.\n";
    }
};

int main() {
    Professor p;
    p.setName("Gajanan");
    p.setDept("Computer Science");
    p.display();
    return 0;
}
```

🧾 Output:

```
Professor Gajanan belongs to Computer Science department.
```

---

## ✅ Summary Table

| Feature                | Description                                   |
| ---------------------- | --------------------------------------------- |
| Definition             | Class inherits from 2+ base classes           |
| Risk                   | Ambiguity if same method exists in both bases |
| Access                 | Inherited members depend on visibility mode   |
| Constructor Order      | Follows order in declaration                  |
| Solution for Ambiguity | Scope resolution operator                     |

---
---
# Lec-42 & 47

## Exercise on C++ Inheritance:
## Solution to Exercise on Cpp Inheritance:

# 🚗 Vehicle System – All Inheritance Types in C++

---

### 👇 Classes We'll Use:

* `Vehicle` – base class
* `Car`, `Bike` – derived classes
* `ElectricCar` – derived from `Car`
* `FlyingCar` – inherits from both `Car` and `Aircraft`
* `Truck` – also inherits from `Vehicle`

---

## ✅ 1. Single Inheritance

> `Car` inherits from `Vehicle`

```cpp
class Vehicle {
public:
    void move() {
        cout << "Moving on road..." << endl;
    }
};

class Car : public Vehicle {
public:
    void type() {
        cout << "This is a Car." << endl;
    }
};
```

---

## ✅ 2. Multilevel Inheritance

> `ElectricCar` → `Car` → `Vehicle`

```cpp
class ElectricCar : public Car {
public:
    void battery() {
        cout << "Runs on electricity." << endl;
    }
};
```

---

## ✅ 3. Multiple Inheritance

> `FlyingCar` inherits from both `Car` and `Aircraft`

```cpp
class Aircraft {
public:
    void fly() {
        cout << "Flying in air..." << endl;
    }
};

class FlyingCar : public Car, public Aircraft {
public:
    void hybrid() {
        cout << "I am a Flying Car." << endl;
    }
};
```

---

## ✅ 4. Hierarchical Inheritance

> Both `Car` and `Truck` inherit from `Vehicle`

```cpp
class Truck : public Vehicle {
public:
    void load() {
        cout << "Carrying goods." << endl;
    }
};
```

---

## ✅ 5. Hybrid Inheritance

> Combination of Hierarchical + Multiple
> For example, `HybridVehicle` inherits from `ElectricCar` and `Truck`

```cpp
class HybridVehicle : public ElectricCar, public Truck {
public:
    void hybridType() {
        cout << "I can carry goods and run on battery!" << endl;
    }
};
```

---

## 🧾 Full Program: All Inheritance Types Together

```cpp
#include <iostream>
using namespace std;

// Base class
class Vehicle {
public:
    void move() {
        cout << "Moving on road..." << endl;
    }
};

// Single & Multilevel
class Car : public Vehicle {
public:
    void type() {
        cout << "This is a Car." << endl;
    }
};

class ElectricCar : public Car {
public:
    void battery() {
        cout << "Runs on electricity." << endl;
    }
};

// Independent base for Multiple
class Aircraft {
public:
    void fly() {
        cout << "Flying in air..." << endl;
    }
};

// Multiple Inheritance
class FlyingCar : public Car, public Aircraft {
public:
    void hybrid() {
        cout << "I am a Flying Car." << endl;
    }
};

// Hierarchical
class Truck : public Vehicle {
public:
    void load() {
        cout << "Carrying goods." << endl;
    }
};

// Hybrid Inheritance
class HybridVehicle : public ElectricCar, public Truck {
public:
    void hybridType() {
        cout << "I can carry goods and run on battery!" << endl;
    }
};

int main() {
    cout << "🔹 Single Inheritance:" << endl;
    Car c;
    c.move();
    c.type();

    cout << "\n🔹 Multilevel Inheritance:" << endl;
    ElectricCar ec;
    ec.move();
    ec.type();
    ec.battery();

    cout << "\n🔹 Multiple Inheritance:" << endl;
    FlyingCar fc;
    fc.type();
    fc.fly();
    fc.hybrid();

    cout << "\n🔹 Hierarchical Inheritance:" << endl;
    Truck t;
    t.move();
    t.load();

    cout << "\n🔹 Hybrid Inheritance:" << endl;
    HybridVehicle hv;
    hv.ElectricCar::move();  // resolve ambiguity from multiple Vehicle inheritance
    hv.battery();
    hv.load();
    hv.hybridType();

    return 0;
}
```

---

### 🧾 Output:

```
🔹 Single Inheritance:
Moving on road...
This is a Car.

🔹 Multilevel Inheritance:
Moving on road...
This is a Car.
Runs on electricity.

🔹 Multiple Inheritance:
This is a Car.
Flying in air...
I am a Flying Car.

🔹 Hierarchical Inheritance:
Moving on road...
Carrying goods.

🔹 Hybrid Inheritance:
Moving on road...
Runs on electricity.
Carrying goods.
I can carry goods and run on battery!
```

---

## ✅ Summary Table

| Inheritance Type | Example Used                             |
| ---------------- | ---------------------------------------- |
| Single           | `Car` ← `Vehicle`                        |
| Multilevel       | `ElectricCar` ← `Car` ← `Vehicle`        |
| Multiple         | `FlyingCar` ← `Car`, `Aircraft`          |
| Hierarchical     | `Car`, `Truck` ← `Vehicle`               |
| Hybrid           | `HybridVehicle` ← `ElectricCar`, `Truck` |

---
---

# Lec -43 //IMP

## Ambiguity Resolution in Inheritance in C++:

## ✅ What is Ambiguity?

> 📌 **Ambiguity occurs when two or more base classes have members with the same name**, and a derived class inherits from them.

Then, the compiler doesn't know **which one** to use — **this causes an error** unless you resolve it.

---

### 🧠 Imagine This:

```cpp
class A {
public:
    void show() { cout << "A" << endl; }
};

class B {
public:
    void show() { cout << "B" << endl; }
};

class C : public A, public B {};

int main() {
    C obj;
    obj.show();  // ❌ Error: Ambiguity!
}
```

🛑 The compiler says:

> *"request for member ‘show’ is ambiguous..."*

Because both `A` and `B` have a `show()` function.

---

## ✅ How to Resolve It?

### 👉 Use **Scope Resolution Operator**:

```cpp
int main() {
    C obj;
    obj.A::show();  // ✅ Calls A’s show()
    obj.B::show();  // ✅ Calls B’s show()
}
```

---

## ✅ Ambiguity with Data Members

```cpp
class A {
public:
    int value = 10;
};

class B {
public:
    int value = 20;
};

class C : public A, public B {
public:
    void showValue() {
        // cout << value; ❌ Ambiguity
        cout << "A's value: " << A::value << endl;
        cout << "B's value: " << B::value << endl;
    }
};
```

---

## ✅ Ambiguity in Diamond Problem

### 🔷 The Diamond Problem

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : public A {};
class C : public A {};
class D : public B, public C {};  // 💎 Diamond shape
```

Now:

```cpp
int main() {
    D obj;
    obj.display();  // ❌ Ambiguity: inherited twice from A
}
```

---

### ✅ Solution: Use **`virtual` inheritance**

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};

int main() {
    D obj;
    obj.display();  // ✅ Now unambiguous
}
```

🎯 **Virtual inheritance** ensures that only **one copy of `A`** exists in `D`.

---

## ✅ Summary Table

| Situation                | Ambiguity Reason                  | Solution                      |
| ------------------------ | --------------------------------- | ----------------------------- |
| Same function in 2 bases | Function conflict                 | Scope resolution (`A::fun()`) |
| Same variable in 2 bases | Variable conflict                 | Scope resolution (`B::var`)   |
| Diamond structure        | Multiple inheritance of same base | Use `virtual` keyword         |

---

## ✅ Real-World Example:

```cpp
class Printer {
public:
    void info() { cout << "Printer Info" << endl; }
};

class Scanner {
public:
    void info() { cout << "Scanner Info" << endl; }
};

class Copier : public Printer, public Scanner {
public:
    void showInfo() {
        Printer::info();  // resolve ambiguity
        Scanner::info();
    }
};
```

---

## ✅ Conclusion:

* Ambiguity is common in **multiple** or **hybrid** inheritance.
* Use:

  * ✅ **Scope resolution operator** for functions/variables
  * ✅ **Virtual inheritance** to fix **diamond problem**

---
---

# Lec-44 & 45

## Virtual Base Class in C++ 
## Code Example Demonstrating Virtual Base Class in C++:

## ✅ What is a Virtual Base Class?

> 📌 A **virtual base class** is used to **prevent multiple “instances”** of a base class when it's **inherited more than once indirectly** — especially in **diamond inheritance problems**.

---

### 🔺 The Diamond Problem

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : public A {};
class C : public A {};
class D : public B, public C {};  // D has 2 copies of A!
```

In this structure:

```
      A
     / \
    B   C
     \ /
      D
```

Now calling:

```cpp
D obj;
obj.display();  // ❌ Ambiguous: 2 copies of A::display()
```

---

## ✅ Solution: Use **virtual inheritance**

```cpp
class A {
public:
    void display() {
        cout << "Class A" << endl;
    }
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};
```

Now:

```cpp
int main() {
    D obj;
    obj.display();  // ✅ Only 1 copy of A — no ambiguity
    return 0;
}
```

✅ This is how **virtual base classes eliminate ambiguity** in the diamond problem.

---

## 🔍 How It Works:

* When you use `virtual` in inheritance:

  * C++ compiler ensures **only one shared instance** of the base class is used.
  * That shared instance is used by all intermediate and derived classes.

---

## 🧠 Real-Life Analogy:

> You attend two workshops — both provide the **same certificate**.
> Without `virtual`, you receive **two duplicate certificates** (confusing!).
> With `virtual`, you get **just one shared certificate** — clear and correct.

---

## ✅ Full Example with Virtual Base

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    void identity() {
        cout << "I am a Person\n";
    }
};

class Employee : virtual public Person {
public:
    void empDetails() {
        cout << "Employee of Company\n";
    }
};

class Student : virtual public Person {
public:
    void study() {
        cout << "Currently studying\n";
    }
};

class Intern : public Employee, public Student {
public:
    void work() {
        cout << "Internship ongoing\n";
    }
};

int main() {
    Intern i;
    i.identity();     // ✅ no ambiguity
    i.empDetails();
    i.study();
    i.work();
    return 0;
}
```

🧾 Output:

```
I am a Person  
Employee of Company  
Currently studying  
Internship ongoing
```

---

## 🧾 Summary Table

| Feature                   | Description                                           |
| ------------------------- | ----------------------------------------------------- |
| Use                       | Resolve ambiguity in **diamond inheritance**          |
| Keyword                   | `virtual` before `public` (or `private`)              |
| Effect                    | Only **1 shared copy** of base class in derived       |
| Common Error Avoided      | "ambiguous base class" or duplicate constructor calls |
| C++ Compiler Optimization | Ensures clean and unambiguous object layout           |

---

## ❗ Key Notes

* Use `virtual` at the **first level** of inheritance (e.g., in `B` and `C`, not in `D`)
* You can combine `virtual` with any visibility mode:

  * `virtual public`
  * `virtual protected`
  * `virtual private`

---
---

# Lec-46 & 48

## Constructors in Derived Class in C++:

## ✅ What is a Constructor?

A **constructor** is a special member function that:

* has the **same name** as the class
* is called **automatically** when an object is created
* is used to **initialize** data members

---

## ✅ Basic Rules for Constructors in Inheritance

| Rule | Explanation                                                                                         |
| ---- | --------------------------------------------------------------------------------------------------- |
| 1.   | Base class constructor is called **before** derived class constructor                               |
| 2.   | If base class constructor needs arguments, derived class must call it using an **initializer list** |
| 3.   | Constructors **are not inherited** by the derived class                                             |
| 4.   | In multiple inheritance, base constructors are called in the **order they are inherited**           |

---

## ✅ Example 1: Default Constructor in Base and Derived Class

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Base class constructor called" << endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Derived class constructor called" << endl;
    }
};

int main() {
    Derived obj;
    return 0;
}
```

🧾 **Output:**

```
Base class constructor called  
Derived class constructor called
```

👉 The **base class constructor runs first**, then the derived class constructor.

---

## ✅ Example 2: Parameterized Constructor in Base Class

```cpp
class Base {
public:
    Base(int x) {
        cout << "Base constructor with value: " << x << endl;
    }
};

class Derived : public Base {
public:
    Derived(int y) : Base(y) {
        cout << "Derived constructor with value: " << y << endl;
    }
};

int main() {
    Derived obj(100);
    return 0;
}
```

🧾 **Output:**

```
Base constructor with value: 100  
Derived constructor with value: 100
```

👉 The **initializer list** is used to call the base class constructor.

---

## ✅ Example 3: Multiple Inheritance Constructor Call

```cpp
class A {
public:
    A() { cout << "A constructor\n"; }
};

class B {
public:
    B() { cout << "B constructor\n"; }
};

class C : public A, public B {
public:
    C() { cout << "C constructor\n"; }
};

int main() {
    C obj;
    return 0;
}
```

🧾 Output:

```
A constructor  
B constructor  
C constructor
```

✅ Constructors are called in the **order of inheritance**, not declaration.

---

## ✅ Example 4: Constructor Order with Virtual Base Class

```cpp
class A {
public:
    A() { cout << "A constructor\n"; }
};

class B : virtual public A {
public:
    B() { cout << "B constructor\n"; }
};

class C : virtual public A {
public:
    C() { cout << "C constructor\n"; }
};

class D : public B, public C {
public:
    D() { cout << "D constructor\n"; }
};

int main() {
    D obj;
    return 0;
}
```

🧾 Output:

```
A constructor  
B constructor  
C constructor  
D constructor
```

✅ `A` is constructed **only once**, even though both `B` and `C` inherit from it — because it's **virtual**.

---

## ✅ Summary Table

| Situation                        | Constructor Call Order               |
| -------------------------------- | ------------------------------------ |
| Simple inheritance               | Base → Derived                       |
| Base constructor with parameters | Use initializer list                 |
| Multiple inheritance             | In order of inheritance declaration  |
| Virtual base class               | Constructed only once (most-derived) |

---

## ✅ Real-Life Analogy

> 👨 Base class = "Person" → sets the name
> 👨‍🎓 Derived class = "Student" → sets roll number

```cpp
class Person {
public:
    Person(string n) {
        cout << "Person: " << n << endl;
    }
};

class Student : public Person {
public:
    Student(string name, int roll) : Person(name) {
        cout << "Student Roll No: " << roll << endl;
    }
};

int main() {
    Student s("Gajanan", 101);
    return 0;
}
```

🧾 Output:

```
Person: Gajanan  
Student Roll No: 101
```

---
---

# Lec-49

## Initialization List in Constructors — C++:

## ✅ What is an Initialization List?

> An **initialization list** is a special syntax used to **initialize data members** of a class **before** the constructor body executes.

---

### 🔹 Syntax:

```cpp
class ClassName {
    int a;
    string name;
public:
    ClassName(int x, string n) : a(x), name(n) {
        // constructor body
    }
};
```

🧠 This initializes `a` with `x`, and `name` with `n` **before** the body of the constructor runs.

---

## ✅ Why Use Initialization List?

| Reason                              | Explanation                                                 |
| ----------------------------------- | ----------------------------------------------------------- |
| Efficiency                          | Directly initializes members instead of assigning later     |
| For `const` members                 | `const` must be initialized at declaration time             |
| For reference (`&`) members         | References must be initialized when declared                |
| For base class constructors         | Required to pass arguments to base class constructor        |
| For member objects of other classes | Required for class-type members with no default constructor |

---

## 🔍 Example 1: Basic Initialization List

```cpp
class Demo {
    int x;
    string msg;
public:
    Demo(int a, string m) : x(a), msg(m) {
        cout << "x = " << x << ", msg = " << msg << endl;
    }
};
```

---

## 🔍 Example 2: Using with `const` and `reference`

```cpp
class ConstRef {
    const int c;
    int& ref;
public:
    ConstRef(int x, int& y) : c(x), ref(y) {
        cout << "const c = " << c << ", ref = " << ref << endl;
    }
};
```

✅ You **must** use initialization list for `const` and `reference` members.

---

## 🔍 Example 3: Member Object Initialization

```cpp
class Engine {
public:
    Engine() {
        cout << "Engine ready!" << endl;
    }
};

class Car {
    Engine e;  // object of another class
public:
    Car() : e() {
        cout << "Car is ready!" << endl;
    }
};
```

🧠 Even though `Engine` has a default constructor, it’s a good habit to initialize explicitly.

---

## 🔍 Example 4: Base Class Initialization

```cpp
class Person {
public:
    Person(string name) {
        cout << "Person: " << name << endl;
    }
};

class Student : public Person {
public:
    Student(string name) : Person(name) {
        cout << "Student constructor done\n";
    }
};
```

✅ Base class constructor is called **before** derived class constructor body runs.

---

## 🚫 What if you don’t use initialization list?

This works fine:

```cpp
Demo(int a, string m) {
    x = a;
    msg = m;
}
```

But it’s:

* ❌ Less efficient for objects (calls default constructor then assigns)
* ❌ Not valid for `const` or reference members

---

## 🧾 Full Example: All Key Uses

```cpp
#include <iostream>
using namespace std;

class Engine {
public:
    Engine() {
        cout << "Engine constructed\n";
    }
};

class Car {
    const int wheels;
    string model;
    Engine e;
public:
    Car(int w, string m) : wheels(w), model(m), e() {
        cout << "Car with " << wheels << " wheels, model: " << model << endl;
    }
};

int main() {
    Car c(4, "Tesla");
    return 0;
}
```

🧾 Output:

```
Engine constructed  
Car with 4 wheels, model: Tesla
```

---

## ✅ Summary Table

| Member Type        | Need for Initialization List |
| ------------------ | ---------------------------- |
| Normal variables   | Optional but recommended     |
| `const` variables  | ✅ Required                   |
| References (`&`)   | ✅ Required                   |
| Objects of class   | ✅ Recommended or required    |
| Base class objects | ✅ Required (if no default)   |

---

## 💡 Best Practice

> ✨ Use initialization lists **always**, especially when:

* Using `const`
* Using references
* Using class-type members
* Inheritance with parameterized constructors

---
---

# Lec-50

## Revisiting Pointers: new and delete Keywords in CPP:

## 🔹 Why Use `new` and `delete`?

C++ allows **dynamic memory allocation** — memory that's allocated **at runtime** — using:

* ✅ `new` → allocates memory on the **heap**
* ✅ `delete` → **frees** memory allocated by `new`

---

## 🔧 Syntax Overview

| Operation             | Syntax                   |
| --------------------- | ------------------------ |
| Allocate single value | `int* ptr = new int;`    |
| Allocate array        | `int* arr = new int[5];` |
| Delete single         | `delete ptr;`            |
| Delete array          | `delete[] arr;`          |

---

## ✅ Example 1: Dynamic Allocation of an `int`

```cpp
#include <iostream>
using namespace std;

int main() {
    int* ptr = new int;   // allocates memory for 1 int

    *ptr = 50;
    cout << "Value: " << *ptr << endl;

    delete ptr;  // frees memory
    return 0;
}
```

🧾 Output:

```
Value: 50
```

🧠 `new` returns the address of the allocated memory. `delete` releases it.

---

## ✅ Example 2: Dynamic Allocation of an Array

```cpp
int main() {
    int n = 3;
    int* arr = new int[n];  // allocates array of 3 ints

    for(int i = 0; i < n; i++)
        arr[i] = i + 1;

    for(int i = 0; i < n; i++)
        cout << arr[i] << " ";

    delete[] arr;  // use delete[] for arrays!
    return 0;
}
```

🧾 Output:

```
1 2 3
```

---

## ⚠️ Common Mistakes to Avoid

| Mistake                       | Fix                         |
| ----------------------------- | --------------------------- |
| Using `delete` on array       | Use `delete[]` instead      |
| Forgetting to `delete` memory | Leads to memory leak        |
| Using pointer after `delete`  | Leads to undefined behavior |

---

## 🧠 Behind the Scenes

* `new` calls the constructor (for classes)
* `delete` calls the destructor (for classes)
* Memory is allocated on the **heap** (not stack)

---

## ✅ Example 3: `new` and `delete` with Classes

```cpp
class Student {
public:
    Student() {
        cout << "Constructor called\n";
    }
    ~Student() {
        cout << "Destructor called\n";
    }
};

int main() {
    Student* s = new Student();  // constructor called
    delete s;                    // destructor called
    return 0;
}
```

🧾 Output:

```
Constructor called  
Destructor called
```

---

## 🧾 Summary Table

| Keyword    | Purpose                | Used With        | Must Do             |
| ---------- | ---------------------- | ---------------- | ------------------- |
| `new`      | Allocate memory (heap) | Single or array  | Assign to a pointer |
| `delete`   | Free single memory     | Pointer          | After use           |
| `delete[]` | Free array memory      | Pointer to array | After use           |

---

## 🧠 Best Practices

* Always `delete` what you `new`
* Use `nullptr` after deleting: `ptr = nullptr;`
* Use **smart pointers** (like `unique_ptr`, `shared_ptr`) in modern C++

---
---

# Lec-51

## Pointers to Objects and Arrow Operator in CPP:

Great topic! Let’s dive into **Pointers to Objects** and the **Arrow Operator (`->`)** in C++. These are essential when working with **dynamic objects**, **arrays of objects**, and **class manipulation** using pointers.

## ✅ What is a Pointer to an Object?

> A **pointer to an object** stores the **address of an object** in memory.
> It can be used to **access members** (variables/functions) of the object.

---

### 👇 Syntax:

```cpp
ClassName obj;
ClassName* ptr = &obj;  // pointer to object
```

---

## ✅ Accessing Members Using a Pointer

You can access object members in two ways:

| Syntax          | Used When...                   |
| --------------- | ------------------------------ |
| `(*ptr).member` | Dereference then access member |
| `ptr->member`   | Shortcut for `(*ptr).member`   |

✔️ `ptr->member` is **cleaner and preferred** in most cases.

---

## ✅ Example: Pointer to Object

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    int id;
    void display() {
        cout << "Student ID: " << id << endl;
    }
};

int main() {
    Student s1;
    s1.id = 101;

    Student* ptr = &s1;

    // Using arrow operator
    ptr->display();

    // Equivalent using (*ptr)
    (*ptr).id = 202;
    (*ptr).display();

    return 0;
}
```

🧾 Output:

```
Student ID: 101  
Student ID: 202
```

---

## ✅ Example: Using `new` with Object Pointers

```cpp
int main() {
    Student* s = new Student;  // dynamic object

    s->id = 500;
    s->display();

    delete s;  // important to free memory
    return 0;
}
```

🧾 Output:

```
Student ID: 500
```

---

## ✅ Example: Array of Objects with Pointer

```cpp
int main() {
    Student* arr = new Student[2];

    arr[0].id = 111;
    arr[1].id = 222;

    arr[0].display();     // or (arr + 0)->display();
    (arr + 1)->display(); // pointer arithmetic

    delete[] arr;
    return 0;
}
```

🧾 Output:

```
Student ID: 111  
Student ID: 222
```

---

## ✅ Arrow Operator: What it Does

```cpp
ptr->member;    // same as (*ptr).member;
```

It's a **syntactic shortcut** that:

* dereferences the pointer (`*ptr`)
* accesses the member using `.`

---

## ✅ Real-Life Analogy

🧠 Think of:

* `ptr` = address of a student
* `ptr->id` = asking that student’s ID directly

Instead of:

```cpp
(*ptr).id   // long form
```

You just write:

```cpp
ptr->id     // cleaner and preferred
```

---

## 🔁 Summary Table

| Concept         | Syntax                   | Example             |
| --------------- | ------------------------ | ------------------- |
| Object pointer  | `ClassName* ptr = &obj;` | `Student* s = &s1;` |
| Access via `*`  | `(*ptr).member`          | `(*s).id = 101;`    |
| Access via `->` | `ptr->member`            | `s->id = 101;`      |
| Dynamic object  | `ptr = new ClassName;`   | `s = new Student;`  |
| Delete object   | `delete ptr;`            | `delete s;`         |
| Delete array    | `delete[] ptr;`          | `delete[] arr;`     |

---

## ✅ Best Practices

* ✅ Always `delete` memory allocated with `new`
* ✅ Use `ptr->` instead of `(*ptr).`
* ✅ Prefer **smart pointers** in modern C++ (`unique_ptr`, `shared_ptr`)

---
---

# Lec-52

## Array of Objects Using Pointers in C++:

## ✅ Basic Idea

You can dynamically create an array of objects using:

```cpp
ClassName* ptr = new ClassName[size];
```

This creates an array of `size` objects on the **heap**.

---

## ✅ Step-by-Step Example

### 📘 Let's create a class `Student` and store 3 students using pointers.

```cpp
#include <iostream>
using namespace std;

class Student {
    int id;
    string name;
public:
    void setData(int i, string n) {
        id = i;
        name = n;
    }

    void display() {
        cout << "ID: " << id << ", Name: " << name << endl;
    }
};

int main() {
    int n = 3;
    Student* arr = new Student[n];  // dynamically create array of objects

    // Setting data
    arr[0].setData(101, "Gajanan");
    arr[1].setData(102, "Rahul");
    arr[2].setData(103, "Sneha");

    // Displaying data
    for (int i = 0; i < n; i++) {
        arr[i].display();  // or (arr + i)->display();
    }

    // Deallocate memory
    delete[] arr;

    return 0;
}
```

---

### 🧾 Output:

```
ID: 101, Name: Gajanan  
ID: 102, Name: Rahul  
ID: 103, Name: Sneha
```

---

## ✅ Accessing with Pointer Arithmetic

You can also use pointer arithmetic instead of array indexing:

```cpp
for (int i = 0; i < n; i++) {
    (arr + i)->display();  // same as arr[i].display();
}
```

---

## ✅ Constructor-Based Example

If your class uses a constructor:

```cpp
class Student {
    int roll;
public:
    Student() {
        roll = 0;  // default
    }

    void setRoll(int r) {
        roll = r;
    }

    void show() {
        cout << "Roll: " << roll << endl;
    }
};

int main() {
    Student* s = new Student[2];  // calls default constructor

    s[0].setRoll(1);
    s[1].setRoll(2);

    s[0].show();
    s[1].show();

    delete[] s;
}
```

---

## 🔥 Important Notes

| Feature                                | Details                              |
| -------------------------------------- | ------------------------------------ |
| `new ClassName[n]`                     | Creates array of objects             |
| `delete[] ptr`                         | Deallocates the entire array         |
| `ptr[i].member` or `(ptr + i)->member` | Access elements                      |
| Use `default constructor`              | Required if using `new ClassName[n]` |

---

## 🧠 Real-Life Analogy

> Imagine making admission entries for 100 students. Instead of writing:

```cpp
Student s1, s2, s3, ..., s100;
```

We just write:

```cpp
Student* s = new Student[100];
```

Efficient, clean, and dynamic!

---

## ✅ Summary

| Task                           | Syntax                               |
| ------------------------------ | ------------------------------------ |
| Create object array            | `ClassName* ptr = new ClassName[n];` |
| Access with index              | `ptr[i].member;`                     |
| Access with pointer arithmetic | `(ptr + i)->member;`                 |
| Free memory                    | `delete[] ptr;`                      |

---
---

# Lec-53

## this Pointer in C++:

## ✅ What is the `this` Pointer?

> 📌 The `this` pointer is an **implicit pointer** available inside **non-static** member functions of a class.
> It points to the **current object** that invoked the member function.

---

### 📘 Syntax:

Inside any non-static function of a class:

```cpp
this->member;  // or
(*this).member;
```

---

## ✅ Why Use the `this` Pointer?

| Use Case                           | Purpose                           |
| ---------------------------------- | --------------------------------- |
| Access current object              | Point to calling object           |
| Resolve variable name conflicts    | When parameter name = member name |
| Return object from member function | Enables **method chaining**       |
| Compare objects (`==`, etc.)       | Compare addresses                 |

---

## ✅ Example 1: Resolving Name Conflict

```cpp
class Student {
    int id;
public:
    void setId(int id) {
        this->id = id;  // 👈 Resolves conflict
    }

    void showId() {
        cout << "ID: " << id << endl;
    }
};

int main() {
    Student s;
    s.setId(101);
    s.showId();
    return 0;
}
```

🧾 Output:

```
ID: 101
```

Without `this->id = id;`, it would assign the **parameter `id` to itself**, not the member variable.

---

## ✅ Example 2: Returning the Current Object

This is used in **method chaining**.

```cpp
class Box {
    int length;
public:
    Box& setLength(int length) {
        this->length = length;
        return *this;  // 👈 Return current object
    }

    void show() {
        cout << "Length: " << length << endl;
    }
};

int main() {
    Box b;
    b.setLength(10).show();  // 👈 Method chaining
    return 0;
}
```

---

## ✅ Example 3: Comparing Two Objects

```cpp
class Person {
public:
    void whoAmI(Person* other) {
        if (this == other)
            cout << "Same object\n";
        else
            cout << "Different objects\n";
    }
};

int main() {
    Person p1, p2;
    p1.whoAmI(&p1);  // ✅ Same object
    p1.whoAmI(&p2);  // ❌ Different object
}
```

---

## ✅ Example 4: Without `this` (when names are different)

```cpp
void setData(int idValue) {
    id = idValue;  // ✅ No need for this if names don’t conflict
}
```

✅ Use `this` only when needed — it’s optional unless there's a **name conflict**.

---

## ❗ Note:

* `this` is **not available** in:

  * Static member functions
  * Non-member functions

---

## ✅ Summary Table

| Feature                   | Explanation                          |
| ------------------------- | ------------------------------------ |
| `this` pointer            | Pointer to the calling object        |
| Used to resolve conflicts | Like: `this->x = x`                  |
| Return from function      | Enables method chaining              |
| Compare objects           | Use `this == &other`                 |
| Type                      | `ClassName*` (pointer to class type) |

---

## 🧠 Real-Life Analogy

> Think of `this` as someone saying “**I myself** did it.”
> When an object calls a function, `this` means **"me, the object that called this"**.

---
---

# Lec-54

## Polymorphism in C++:

## ✅ What is Polymorphism?

> 📌 **Polymorphism** means "**many forms**".
> In C++, it allows **the same function or operator** to behave **differently** based on:

* The **object** it is acting on
* The **context** in which it's used

---

## ✅ Types of Polymorphism in C++

| Type            | Description              | Also Called          |
| --------------- | ------------------------ | -------------------- |
| 1. Compile-time | Resolved at compile time | Static Polymorphism  |
| 2. Run-time     | Resolved at runtime      | Dynamic Polymorphism |

---

## 🔹 1. Compile-Time Polymorphism

Achieved using:

* ✅ **Function Overloading**
* ✅ **Operator Overloading**

---

### 🧪 Example: Function Overloading

```cpp
class Print {
public:
    void show(int x) {
        cout << "Integer: " << x << endl;
    }

    void show(string s) {
        cout << "String: " << s << endl;
    }
};

int main() {
    Print p;
    p.show(100);
    p.show("Hello");
    return 0;
}
```

🧾 Output:

```
Integer: 100  
String: Hello
```

---

### 🧪 Example: Operator Overloading

```cpp
class Complex {
    int real, imag;
public:
    Complex(int r, int i) : real(r), imag(i) {}

    Complex operator + (const Complex& obj) {
        return Complex(real + obj.real, imag + obj.imag);
    }

    void display() {
        cout << real << " + " << imag << "i\n";
    }
};

int main() {
    Complex c1(1, 2), c2(3, 4), c3(0, 0);
    c3 = c1 + c2;
    c3.display();
    return 0;
}
```

🧾 Output:

```
4 + 6i
```

---

## 🔹 2. Run-Time Polymorphism

Achieved using:

* ✅ **Function Overriding**
* ✅ **Virtual Functions + Base Class Pointer**

---

### 🧪 Example: Function Overriding with Virtual Function

```cpp
class Animal {
public:
    virtual void sound() {
        cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() override {
        cout << "Bark\n";
    }
};

int main() {
    Animal* a;
    Dog d;
    a = &d;

    a->sound();  // Calls Dog's version (due to virtual)
    return 0;
}
```

🧾 Output:

```
Bark
```

👉 This is **runtime polymorphism** — the function call is resolved **at runtime** using a **virtual function**.

---

### 🔍 Without `virtual`?

```cpp
class Animal {
public:
    void sound() { cout << "Animal sound\n"; }
};
```

Then `a->sound();` will call **Animal's** version, not Dog's — even if `a` points to a `Dog`.

---

## 🎯 Virtual Function Rules

* Must be in **base class**
* Enables **late binding** (runtime resolution)
* Use `override` in derived class for safety (C++11+)

---

## ✅ Summary Table

| Type         | Implemented Using               | Resolves At  | Example Function              |
| ------------ | ------------------------------- | ------------ | ----------------------------- |
| Compile-Time | Function / Operator Overloading | Compile Time | `show(int)` vs `show(string)` |
| Run-Time     | Virtual Function + Pointer      | Run Time     | `a->sound();`                 |

---

## 🧠 Real-Life Analogy

> You can press a **"play" button**:

* On a **TV**, it plays a movie
* On a **music player**, it plays a song
* On a **gaming console**, it starts a game

The **action is same** (`play()`), but **behavior depends on object type** — this is polymorphism!

---

## ✅ Conclusion

Polymorphism lets you:

✔️ Write **flexible and extensible** code
✔️ Use **same interface**, but allow **different behaviors**
✔️ Achieve **code reusability** and **runtime decision-making**

---
---

# Lec-55

## 













