# Lec-21

## Classes, Public and Private access modifiers:

## 🔷 1. **What is a Class?**

> A **class** is a **user-defined data type** that holds **data (variables)** and **functions** together.

A class is like a **blueprint** for creating **objects**.

---

### ✅ Syntax of a Class:

```cpp
class ClassName {
    // Access modifier
public:
    // accessible everywhere

private:
    // accessible only inside the class
};
```
---

## 🔷 2. **Access Modifiers**

Access modifiers decide **who can access what** in a class.

| Modifier    | Access Scope                                           |
| ----------- | ------------------------------------------------------ |
| `public`    | Accessible from **anywhere** (inside or outside class) |
| `private`   | Accessible **only within the class**                   |
| `protected` | (covered in inheritance, used in derived classes)      |

---

### ⚠️ Important:

* By default, **members of a class are `private`**.
* Use `public` for functions that should be accessed from outside.
* Use `private` to **protect sensitive data**.

---

## ✅ Summary Table

| Term    | Meaning                        |
| ------- | ------------------------------ |
| Class   | Blueprint to create objects    |
| Object  | Real instance of a class       |
| Public  | Can be accessed from outside   |
| Private | Only accessed within the class |

---

### 🧠 Why Use Access Modifiers?

✅ Helps in **data hiding** (important OOP concept)
✅ Prevents **unauthorized access**
✅ Makes code **secure and modular**

---

### 🔧 Bonus Tip:

You can also declare:

```cpp
class MyClass {
    int x;         // private by default
public:
    int y;
};
```

---
---

# Lec-22

## OOPs Recap & Nesting of Member Functions:

### 🔷 What is Nesting of Member Functions?

> 📌 **Nesting of member functions** means calling **one member function of a class from another member function** **within the same class**.

This helps break logic into **smaller reusable parts**.

---

### ✅ Example: Simple Program with Nesting

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int marks1, marks2;

    int totalMarks() {
        return marks1 + marks2;
    }

public:
    void setMarks(int m1, int m2) {
        marks1 = m1;
        marks2 = m2;
    }

    void displayResult() {
        int total = totalMarks();  // nested call
        cout << "Total Marks: " << total << endl;
    }
};

int main() {
    Student s;
    s.setMarks(85, 90);
    s.displayResult();

    return 0;
}
```

---

🧾 Output:

```
Total Marks: 175
```

---

### 🔍 Explanation:

* `totalMarks()` is a **private function**
* It’s **called inside `displayResult()`**, which is public
* This is **nesting of member functions**

---

## 🔁 Use Case

| Function          | Purpose                           |
| ----------------- | --------------------------------- |
| `setMarks()`      | Set values from main function     |
| `displayResult()` | Calls private function internally |
| `totalMarks()`    | Nested inside displayResult()     |

---

## ✅ Key Points

* One member function **can access other members directly**
* You can call a private member function from a **public** one inside the class
* This is useful for breaking large logic into smaller **private helper functions**

---

## ✅ Summary Table

| Concept                  | Description                                     |
| ------------------------ | ----------------------------------------------- |
| Nested Member Function   | Function calling another function of same class |
| Access Modifier Allowed? | Yes, including private if called inside class   |
| Common Use               | Reuse logic, organize code inside a class       |

---
---

# Lec-23

## C++ Objects Memory Allocation & using Arrays in Classes:

### 🔷 1. **C++ Objects Memory Allocation**

When you create an **object** of a class, memory is **only allocated for the data members** — **not the member functions**.

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Demo {
public:
    int x;
    float y;

    void display() {
        cout << "x: " << x << ", y: " << y << endl;
    }
};

int main() {
    Demo obj1, obj2;  // two objects created

    obj1.x = 10;
    obj1.y = 3.14;

    obj2.x = 20;
    obj2.y = 2.71;

    obj1.display();
    obj2.display();

    return 0;
}
```

🧾 Output:

```
x: 10, y: 3.14  
x: 20, y: 2.71
```

---

### 🧠 Memory Notes:

* `obj1` and `obj2` each get **separate memory** for `x` and `y`.
* **Member functions are shared** by all objects — only one copy in memory.

📌 So, **memory is allocated per object only for data members**, not functions.

---

## 🔷 2. **Using Arrays in Classes**

Arrays can be used as:

* **Data members** (inside a class)
* Or **objects of class stored in an array**

---

### ✅ A. **Array as Data Member**

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    int marks[5];  // array inside class

public:
    void setMarks() {
        cout << "Enter 5 subject marks: ";
        for (int i = 0; i < 5; i++) {
            cin >> marks[i];
        }
    }

    void displayMarks() {
        cout << "Marks are: ";
        for (int i = 0; i < 5; i++) {
            cout << marks[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    Student s1;
    s1.setMarks();
    s1.displayMarks();
    return 0;
}
```

---

### ✅ B. **Array of Objects**

```cpp
#include <iostream>
using namespace std;

class Book {
public:
    string title;
    void setData(string t) {
        title = t;
    }
    void show() {
        cout << "Title: " << title << endl;
    }
};

int main() {
    Book library[3];  // array of objects

    library[0].setData("C++ Programming");
    library[1].setData("Python Essentials");
    library[2].setData("Data Structures");

    for (int i = 0; i < 3; i++) {
        library[i].show();
    }

    return 0;
}
```

🧾 Output:

```
Title: C++ Programming  
Title: Python Essentials  
Title: Data Structures
```

---

## ✅ Summary Table

| Concept                  | Description                                      |
| ------------------------ | ------------------------------------------------ |
| Object memory allocation | Memory given to data members, not functions      |
| Array as data member     | Use arrays inside class (e.g., marks\[5])        |
| Array of objects         | Create multiple objects with `ClassName obj[n];` |

---
---

# Lec-24 //IMP

## Static Data Members & Methods in C++ OOPS:

## 🔷 1. **Static Data Members**

### 📌 What is it?

A **static data member** belongs to the **class itself**, not to any specific object.
It is **shared among all objects** of that class.

---

### ✅ Syntax:

```cpp
class ClassName {
public:
    static int count;  // declaration
};
int ClassName::count = 0;  // definition outside class
```

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    static int totalStudents;
    string name;

    Student(string n) {
        name = n;
        totalStudents++;
    }

    void show() {
        cout << "Name: " << name << ", Total: " << totalStudents << endl;
    }
};

int Student::totalStudents = 0;  // static member defined outside

int main() {
    Student s1("Gajanan");
    Student s2("Amit");

    s1.show();  // Output: Total: 2
    s2.show();  // Output: Total: 2

    return 0;
}
```

---

🧾 Output:

```
Name: Gajanan, Total: 2  
Name: Amit, Total: 2
```

---

### 🧠 Key Points:

| Property                    | Static Data Member                 |
| --------------------------- | ---------------------------------- |
| Shared across all objects   | ✅ Yes                              |
| Belongs to object?          | ❌ No, belongs to class             |
| Needs definition outside?   | ✅ Yes                              |
| Accessed by object or class | Both `obj.count` or `Class::count` |

---

## 🔷 2. **Static Member Functions**

### 📌 What is it?

A **static function** in a class can **only access static members**.
It **doesn’t require any object** to be called.

---

### ✅ Syntax:

```cpp
class ClassName {
public:
    static void functionName();
};
```

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Counter {
private:
    static int count;

public:
    static void showCount() {
        cout << "Count: " << count << endl;
    }

    Counter() {
        count++;
    }
};

int Counter::count = 0;

int main() {
    Counter c1, c2, c3;

    Counter::showCount();  // Static function called without object

    return 0;
}
```

🧾 Output:

```
Count: 3
```

---

### 🧠 Key Rules:

| Rule                                | Applies to Static Member Function? |
| ----------------------------------- | ---------------------------------- |
| Can access static members?          | ✅ Yes                              |
| Can access non-static members?      | ❌ No (needs object for that)       |
| Can be called using object or class | ✅ Yes                              |

---

## ✅ Summary Table

| Feature                 | Static Data Member | Static Function |
| ----------------------- | ------------------ | --------------- |
| Shared across objects   | ✅ Yes              | ✅ Yes           |
| Access non-static data? | ❌ No               | ❌ No            |
| Called using class name | ✅ Yes              | ✅ Yes           |
| Needs object to access  | ❌ No               | ❌ No            |

---

### 🧠 Real-Life Use Cases

* Count number of objects created
* Common configuration (e.g., `pi`, tax rate)
* Class-wide helper functions

---
---

# Lec-25

## Array of Objects & Passing Objects as Function Arguments in C++:

## 🔷 1. **Array of Objects**

> 📌 You can store **multiple objects** of a class in an array — just like how you store integers in an `int` array.

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    string name;
    int roll;

    void getData() {
        cout << "Enter name and roll: ";
        cin >> name >> roll;
    }

    void display() {
        cout << "Name: " << name << ", Roll: " << roll << endl;
    }
};

int main() {
    Student s[3];  // Array of 3 Student objects

    for (int i = 0; i < 3; i++) {
        s[i].getData();     // Input for each object
    }

    for (int i = 0; i < 3; i++) {
        s[i].display();     // Display data of each object
    }

    return 0;
}
```

---

### 🧾 Sample Input/Output:

```
Enter name and roll: A 1  
Enter name and roll: B 2  
Enter name and roll: C 3  
Name: A, Roll: 1  
Name: B, Roll: 2  
Name: C, Roll: 3
```

---

## 🔷 2. **Passing Objects as Function Arguments**

> 📌 You can pass objects to functions just like variables.
> There are **three** ways to do this:

---

### ✅ A. **Pass by Value** (Copy of object is passed)

```cpp
void display(Student s) {
    cout << s.name << " " << s.roll << endl;
}
```

* Does **not affect** original object
* Slightly **slower** due to copy

---

### ✅ B. **Pass by Reference** (Changes original object)

```cpp
void modify(Student &s) {
    s.roll += 100;  // changes actual roll
}
```

* **Faster**
* Can **modify the original object**

---

### ✅ C. **Pass by Pointer**

```cpp
void show(Student* s) {
    cout << s->name << " " << s->roll << endl;
}
```

* Use `->` to access members
* Useful in **dynamic memory**

---

### ✅ Full Example: Pass by Reference

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    string name;
    int roll;

    void setData(string n, int r) {
        name = n;
        roll = r;
    }

    void display() {
        cout << name << " " << roll << endl;
    }
};

// Function to update roll
void updateRoll(Student &s) {
    s.roll += 10;
}

int main() {
    Student s1;
    s1.setData("Gajanan", 101);

    updateRoll(s1);    // passed by reference
    s1.display();      // Updated roll: 111

    return 0;
}
```

🧾 Output:

```
Gajanan 111
```

---

## ✅ Summary Table

| Concept                 | Meaning                             |
| ----------------------- | ----------------------------------- |
| Array of Objects        | Store multiple objects in one array |
| Pass by Value           | Copies object (safe, slower)        |
| Pass by Reference (`&`) | Affects original object             |
| Pass by Pointer (`*`)   | Uses pointer and `->` operator      |

---
---

# Lec-26 //IMP

## Friend Functions in C++:

## ✅ **Friend Functions in C++**

A `friend` function is a special function that can **access private and protected members** of a class — **even though it’s not a member of the class**.

---

### 🔷 Why use Friend Functions?

Normally, **only member functions** can access private members.
But sometimes, we want **external functions** to access them (for utility or operator overloading).

---

## 🔷 Syntax:

```cpp
class ClassName {
    friend return_type function_name(parameters);  // friend function declaration
};
```

---

## ✅ Example: Friend Function Accessing Private Data

```cpp
#include <iostream>
using namespace std;

class Box {
private:
    int length;

public:
    Box() { length = 10; }

    // Friend function declaration
    friend void showLength(Box b);
};

// Friend function definition (not inside class)
void showLength(Box b) {
    // Accessing private member directly
    cout << "Length is: " << b.length << endl;
}

int main() {
    Box b1;
    showLength(b1);  // call friend function
    return 0;
}
```

🧾 Output:

```
Length is: 10
```

---

## ✅ Key Points:

| Feature                      | Friend Function                          |
| ---------------------------- | ---------------------------------------- |
| Can access private data?     | ✅ Yes                                    |
| Is it a member of the class? | ❌ No                                     |
| How to define?               | Use `friend` keyword inside class        |
| Where to define body?        | Outside the class like a normal function |
| Called using object?         | No, it takes object as argument          |

---

## 🔷 Real-World Example: Add Two Complex Numbers

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    int real, imag;

public:
    Complex(int r, int i) {
        real = r;
        imag = i;
    }

    // Declare friend function
    friend void addComplex(Complex c1, Complex c2);
};

// Define friend function
void addComplex(Complex c1, Complex c2) {
    cout << "Sum = " << (c1.real + c2.real) << " + " << (c1.imag + c2.imag) << "i" << endl;
}

int main() {
    Complex a(4, 5), b(2, 3);
    addComplex(a, b);  // call friend function
    return 0;
}
```

🧾 Output:

```
Sum = 6 + 8i
```

---

## ✅ Summary Table

| Property                  | Friend Function                          |
| ------------------------- | ---------------------------------------- |
| Access to private members | ✅ Yes                                    |
| Member of class?          | ❌ No                                     |
| Keyword used              | `friend`                                 |
| Usage                     | When external function needs full access |

---
---

# Lec-27 //IMP

## Friend Classes & Member Friend Functions in C++:

## 🔷 1. **Friend Class in C++**

> 📌 A **friend class** can access **private and protected members** of another class.

---

### ✅ Syntax:

```cpp
class B;  // forward declaration

class A {
    friend class B;  // B is a friend of A
private:
    int secret = 42;
};

class B {
public:
    void showSecret(A obj) {
        cout << "Accessed A's private data: " << obj.secret << endl;
    }
};
```

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class B;  // forward declaration

class A {
private:
    int data = 100;

    // declaring class B as a friend
    friend class B;
};

class B {
public:
    void display(A obj) {
        cout << "Accessing A's private data: " << obj.data << endl;
    }
};

int main() {
    A a1;
    B b1;
    b1.display(a1);
    return 0;
}
```

🧾 Output:

```
Accessing A's private data: 100
```

---

### 🔑 Key Notes:

| Feature                   | Friend Class   |
| ------------------------- | -------------- |
| Access private members?   | ✅ Yes          |
| Is a member of the class? | ❌ No           |
| Bidirectional friendship? | ❌ One-way only |

If `B` is a friend of `A`, then `A`'s members can be accessed by `B`, but not the other way around.

---

## 🔷 2. **Member Function as Friend (Member Friend Function)**

> 📌 You can make **only a specific member function** of another class your friend.

---

### ✅ Syntax:

```cpp
class A;

class B {
public:
    void show(A obj);  // Only this function will be a friend
};

class A {
private:
    int value = 55;

    // only B::show() is friend, not entire class B
    friend void B::show(A);
};

void B::show(A obj) {
    cout << "Value from A: " << obj.value << endl;
}
```

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class A;  // forward declaration

class B {
public:
    void display(A obj);  // declare before class A
};

class A {
private:
    int x = 500;

    // make only B::display a friend
    friend void B::display(A);
};

void B::display(A obj) {
    cout << "Accessing A's private x: " << obj.x << endl;
}

int main() {
    A a1;
    B b1;
    b1.display(a1);
    return 0;
}
```

🧾 Output:

```
Accessing A's private x: 500
```

---

### ✅ Summary Table

| Concept                      | Friend Class              | Member Friend Function              |
| ---------------------------- | ------------------------- | ----------------------------------- |
| What is a friend?            | Whole class               | Specific function of another class  |
| Access to private members?   | ✅ Yes                     | ✅ Yes                               |
| Friend declaration in class? | `friend class ClassName;` | `friend return_type Class::func();` |
| Use case                     | Deep class integration    | Limited, function-level access      |

---
---

# Lec-28

## More on C++ Friend Functions (Examples & Explanation):

## 🔁 RECAP: What is a Friend Function?

A **friend function**:

* Is **not a member** of the class
* But it has **access to private and protected members**
* Is declared using the `friend` keyword inside the class

---

## ✅ Example 1: Simple Friend Function

### 📌 Use case: Accessing private members from outside

```cpp
#include <iostream>
using namespace std;

class Box {
private:
    int length;

public:
    Box() {
        length = 10;
    }

    // friend function declaration
    friend void printLength(Box b);
};

// friend function definition
void printLength(Box b) {
    cout << "Length is: " << b.length << endl;  // access private data
}

int main() {
    Box b;
    printLength(b);  // call friend function
    return 0;
}
```

🧾 Output:

```
Length is: 10
```

---

## ✅ Example 2: Add Two Complex Numbers (Friend Function)

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    int real, imag;

public:
    void setData(int r, int i) {
        real = r;
        imag = i;
    }

    // Declare friend
    friend Complex addComplex(Complex c1, Complex c2);
};

// Friend function can access private members of Complex
Complex addComplex(Complex c1, Complex c2) {
    Complex result;
    result.real = c1.real + c2.real;
    result.imag = c1.imag + c2.imag;
    return result;
}

int main() {
    Complex a, b, sum;
    a.setData(2, 3);
    b.setData(4, 5);
    sum = addComplex(a, b);

    cout << "Sum = " << sum.real << " + " << sum.imag << "i" << endl;
    return 0;
}
```

🧾 Output:

```
Sum = 6 + 8i
```

---

## ✅ Example 3: Comparing Private Members of Two Classes

```cpp
#include <iostream>
using namespace std;

class B;  // forward declaration

class A {
private:
    int val;

public:
    A(int x) { val = x; }
    friend void compare(A, B);
};

class B {
private:
    int val;

public:
    B(int x) { val = x; }
    friend void compare(A, B);
};

// Friend function for both classes
void compare(A objA, B objB) {
    if (objA.val > objB.val)
        cout << "A is greater" << endl;
    else if (objA.val < objB.val)
        cout << "B is greater" << endl;
    else
        cout << "Both are equal" << endl;
}

int main() {
    A a(10);
    B b(20);
    compare(a, b);  // friend function can access private members
    return 0;
}
```

🧾 Output:

```
B is greater
```

---

## 🔑 Key Properties of Friend Functions

| Feature                   | Friend Function                |
| ------------------------- | ------------------------------ |
| Access to private members | ✅ Yes                          |
| Member of the class?      | ❌ No                           |
| Declared inside class?    | ✅ Yes, with `friend` keyword   |
| Defined outside class     | ✅ Like a normal function       |
| Called using object?      | ❌ It takes object as parameter |

---

## ❗ Important Notes

* Friendship is **not inherited**.
* Friendship is **not mutual**:

  * If A is friend of B, then B is **not automatically** friend of A.
* It **breaks encapsulation**, so use **only when necessary**.

---

## ✅ Summary

| Concept         | Meaning                                                         |
| --------------- | --------------------------------------------------------------- |
| Friend Function | External function that can access private data of a class       |
| Use Cases       | Utility functions, operator overloading, inter-class logic      |
| Declaration     | `friend return_type function_name(ClassName);` inside the class |
| Definition      | Outside the class (normal function syntax)                      |

---
---

# Lec-29

## Constructors in C++:

### 🔷 What is a Constructor?

> 📌 A **constructor** is a **special function** that **automatically runs** when an object is created.
> It is used to **initialize data members** of a class.

---

## ✅ Key Features of Constructors:

| Feature              | Details                                |
| -------------------- | -------------------------------------- |
| Same name as class   | Yes                                    |
| No return type       | Not even `void`                        |
| Called automatically | When object is created                 |
| Can be overloaded    | ✅ Yes (multiple constructors possible) |

---

## ✅ Basic Constructor Example:

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    string name;

    // Constructor
    Student() {
        cout << "Constructor called!" << endl;
        name = "Unknown";
    }

    void show() {
        cout << "Name: " << name << endl;
    }
};

int main() {
    Student s1;  // Constructor will be called automatically
    s1.show();
    return 0;
}
```

🧾 Output:

```
Constructor called!  
Name: Unknown
```

---

## 🔷 Types of Constructors

| Type                    | Description                            |
| ----------------------- | -------------------------------------- |
| **Default Constructor** | No parameters                          |
| **Parameterized**       | Takes arguments to initialize values   |
| **Copy Constructor**    | Copies data from one object to another |

---
---

# Lec-30

## Parameterized and Default Constructors In C++:

## 🔷 1. **Default Constructor in C++**

> 📌 A **default constructor** is a constructor that takes **no arguments**. It’s used to **initialize objects with default values**.

---

### ✅ Syntax:

```cpp
class ClassName {
public:
    ClassName() {
        // default initialization
    }
};
```

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    string name;
    int roll;

    // Default Constructor
    Student() {
        name = "Unknown";
        roll = 0;
    }

    void display() {
        cout << "Name: " << name << ", Roll: " << roll << endl;
    }
};

int main() {
    Student s1;  // Default constructor called
    s1.display();
    return 0;
}
```

🧾 Output:

```
Name: Unknown, Roll: 0
```

---

## 🔷 2. **Parameterized Constructor in C++**

> 📌 A **parameterized constructor** takes **arguments** and uses them to **initialize the object with specific values**.

---

### ✅ Syntax:

```cpp
class ClassName {
public:
    ClassName(type a, type b) {
        // assign values
    }
};
```

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    string name;
    int roll;

    // Parameterized Constructor
    Student(string n, int r) {
        name = n;
        roll = r;
    }

    void display() {
        cout << "Name: " << name << ", Roll: " << roll << endl;
    }
};

int main() {
    Student s1("Gajanan", 101);  // Parameterized constructor
    s1.display();
    return 0;
}
```

🧾 Output:

```
Name: Gajanan, Roll: 101
```

---

## 🔄 What if Both Constructors Are Present?

You can **overload** constructors by creating both default and parameterized versions:

```cpp
class Demo {
public:
    Demo() {
        cout << "Default constructor\n";
    }

    Demo(int x) {
        cout << "Parameterized constructor: " << x << endl;
    }
};
```

✅ The correct constructor will be selected **based on how you create the object**.

---

## ✅ Summary Table

| Constructor Type          | Arguments? | Purpose                      | Called When              |
| ------------------------- | ---------- | ---------------------------- | ------------------------ |
| Default Constructor       | ❌ No       | Initialize with fixed values | `Class obj;`             |
| Parameterized Constructor | ✅ Yes      | Initialize with given values | `Class obj(val1, val2);` |

---

## 💡 Tip:

If you define a **parameterized constructor**, the compiler **does not create a default constructor** automatically. So if needed, define both manually.

---
---

# Lec-31

## Constructor Overloading In C++:

### 🔷 What is Constructor Overloading?

> 📌 **Constructor overloading** means having **multiple constructors** in the same class with **different sets of parameters**.

It allows creating objects **in multiple ways**.

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    string name;
    int roll;

    // Default Constructor
    Student() {
        name = "Unknown";
        roll = 0;
    }

    // Parameterized Constructor
    Student(string n, int r) {
        name = n;
        roll = r;
    }

    void display() {
        cout << "Name: " << name << ", Roll: " << roll << endl;
    }
};

int main() {
    Student s1;                   // calls default constructor
    Student s2("Gajanan", 101);   // calls parameterized constructor

    s1.display();
    s2.display();

    return 0;
}
```

🧾 Output:

```
Name: Unknown, Roll: 0  
Name: Gajanan, Roll: 101
```

---

## 🔷 Key Rules of Constructor Overloading

| Rule                                            | Explanation                                  |
| ----------------------------------------------- | -------------------------------------------- |
| Constructors must have **different parameters** | Different in **number** or **type**          |
| Return type?                                    | ❌ Constructors have **no return type**       |
| Called automatically                            | ✅ Yes, when object is created                |
| Overloading based on name?                      | ❌ Not needed — constructor name = class name |

---

## ✅ Summary Table

| Constructor Type      | Called When        | Purpose                         |
| --------------------- | ------------------ | ------------------------------- |
| `ClassName()`         | `Class obj;`       | Default initialization          |
| `ClassName(int)`      | `Class obj(5);`    | Square/one value initialization |
| `ClassName(int, int)` | `Class obj(3, 4);` | Custom values                   |

---

## ❗ Note:

Constructor overloading improves **flexibility** and supports **code reuse** by allowing different ways to initialize objects.

---

### ✅ Real-life Example Use Cases:

* Creating an `Account` with or without balance
* Creating a `Student` with or without full details
* Creating a `Date` with current date or a specific date

---
---

# Lec-32

## Constructors With Default Arguments In C++:

### 🔷 What is it?

> 📌 A **constructor with default arguments** allows you to call it with **fewer or no parameters**, while still initializing values.

This is a shortcut instead of overloading multiple constructors.

---

### ✅ Syntax:

```cpp
class ClassName {
public:
    ClassName(int a = 10, int b = 20) {
        // initialization
    }
};
```

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Constructor with default arguments
    Student(string n = "Unknown", int a = 18) {
        name = n;
        age = a;
    }

    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    Student s1;                  // uses default values
    Student s2("Gajanan");       // age will be 18
    Student s3("Amit", 21);      // both values provided

    s1.display();
    s2.display();
    s3.display();

    return 0;
}
```

---

🧾 Output:

```
Name: Unknown, Age: 18  
Name: Gajanan, Age: 18  
Name: Amit, Age: 21
```

---

### 🔁 How is it Different from Overloading?

| Feature                   | Constructor Overloading | Default Arguments                |
| ------------------------- | ----------------------- | -------------------------------- |
| Multiple functions needed | ✅ Yes                   | ❌ No — one constructor is enough |
| Simpler code              | ❌ Less                  | ✅ More concise                   |
| Flexibility               | ✅ Good                  | ✅ Also good                      |

---

## 🔷 Key Rules:

* **Default arguments must be given from right to left**

  ```cpp
  ClassName(int a, int b = 10);  // ✅ OK  
  ClassName(int a = 10, int b);  // ❌ Error
  ```

* If values are provided at the time of object creation, **those override the defaults**

---

## ✅ Summary

| Concept                      | Description                                   |
| ---------------------------- | --------------------------------------------- |
| Default Argument Constructor | Constructor with pre-defined parameter values |
| Benefit                      | Write fewer overloaded constructors           |
| Call Variants                | Zero, one, or all arguments can be passed     |

---
---
 
# Lec-33 // IMP

## Dynamic Initialization of Objects Using Constructors:

### 🔷 What is Dynamic Initialization?

> 📌 **Dynamic initialization** means initializing object **data members at runtime**, usually using values **entered by the user** or **calculated during program execution**.

This is done through **parameterized constructors**.

---

### ✅ Why Use It?

* To provide **flexibility** in object creation
* When values aren't known at compile-time
* Useful in programs involving user input, file data, or runtime calculations

---

## ✅ Example: Basic Dynamic Initialization

```cpp
#include <iostream>
using namespace std;

class Rectangle {
    int length, breadth;

public:
    // Parameterized constructor
    Rectangle(int l, int b) {
        length = l;
        breadth = b;
    }

    int area() {
        return length * breadth;
    }
};

int main() {
    int l, b;
    cout << "Enter length and breadth: ";
    cin >> l >> b;

    // Dynamic initialization at runtime
    Rectangle r(l, b);
    cout << "Area = " << r.area() << endl;

    return 0;
}
```

🧾 Output:

```
Enter length and breadth: 5 3  
Area = 15
```

---

## 🔷 Use Case: Initialize with User Input

```cpp
class Student {
    string name;
    int age;

public:
    Student(string n, int a) {
        name = n;
        age = a;
    }

    void show() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    string n;
    int a;
    cout << "Enter name and age: ";
    cin >> n >> a;

    Student s(n, a);  // dynamically initialized
    s.show();

    return 0;
}
```

---

## 🔷 Use Case: Calculated Values

```cpp
class Circle {
    float radius;

public:
    Circle(float r) {
        radius = r;
    }

    float area() {
        return 3.14 * radius * radius;
    }
};

int main() {
    float r;
    cout << "Enter radius: ";
    cin >> r;

    Circle c(r);  // dynamic based on input
    cout << "Area = " << c.area() << endl;
    return 0;
}
```

---

## ✅ Summary

| Concept                | Description                                             |
| ---------------------- | ------------------------------------------------------- |
| Dynamic Initialization | Initialize object at runtime with variable/input values |
| Constructor Used       | ✅ Parameterized constructor                             |
| Common Use Cases       | User input, runtime logic, file reading, etc.           |

---
---

# Lec-34

## Copy Constructor in C++:

### 🔷 What is a Copy Constructor?

> 📌 A **copy constructor** creates a **new object** by **copying data from an existing object** of the same class.

---

### ✅ Syntax:

```cpp
ClassName(const ClassName &old_object) {
    // copy logic
}
```

---

### ✅ Why Use a Copy Constructor?

* To **initialize one object using another**
* To **copy data safely**, especially when using **pointers or dynamic memory**
* It helps in **passing/returning objects by value**

---

## ✅ Example: Simple Copy Constructor

```cpp
#include <iostream>
using namespace std;

class Student {
    string name;
    int roll;

public:
    // Parameterized constructor
    Student(string n, int r) {
        name = n;
        roll = r;
    }

    // Copy constructor
    Student(const Student &s) {
        name = s.name;
        roll = s.roll;
    }

    void display() {
        cout << "Name: " << name << ", Roll: " << roll << endl;
    }
};

int main() {
    Student s1("Gajanan", 101);
    Student s2 = s1;  // copy constructor called

    s1.display();
    s2.display();

    return 0;
}
```

🧾 Output:

```
Name: Gajanan, Roll: 101  
Name: Gajanan, Roll: 101
```

---

## 🔷 When is Copy Constructor Called?

| Situation                                | Copy Constructor Called? |
| ---------------------------------------- | ------------------------ |
| Object initialized using another object  | ✅ Yes                    |
| Object passed by value to a function     | ✅ Yes                    |
| Object returned by value from a function | ✅ Yes                    |

---

### ✅ Example: Passing Object by Value

```cpp
void show(Student s) {
    s.display();  // copy constructor is called here
}
```

---

## 🔷 Shallow vs Deep Copy

If a class uses pointers, **default copy constructor does shallow copy**, which can lead to issues (like double deletion).

---

### ✅ Deep Copy Example:

```cpp
class Array {
    int* data;

public:
    Array(int val) {
        data = new int;
        *data = val;
    }

    // Deep copy constructor
    Array(const Array &a) {
        data = new int;
        *data = *(a.data);  // copy the value, not the address
    }

    void show() {
        cout << "Value: " << *data << endl;
    }

    ~Array() {
        delete data;
    }
};
```

---

## ✅ Default vs User-Defined Copy Constructor

| Feature                    | Default Copy Constructor | User-Defined Copy Constructor |
| -------------------------- | ------------------------ | ----------------------------- |
| Created automatically?     | ✅ Yes                    | ❌ No, you define it manually  |
| Does deep copy?            | ❌ No (shallow copy only) | ✅ Yes (you control it)        |
| Needed when pointers used? | ✅ Strongly recommended   | ✅ Yes                         |

---

## ✅ Summary

| Feature              | Copy Constructor                               |
| -------------------- | ---------------------------------------------- |
| Purpose              | Copy data from another object                  |
| Syntax               | `ClassName(const ClassName &obj)`              |
| Default provided?    | ✅ Yes (shallow copy)                           |
| Needed for pointers? | ✅ Yes (for deep copy)                          |
| When it's called     | Initialization, pass by value, return by value |

---
---

# Lec-35

## Destructor in C++:

### 🔷 What is a Destructor?

> 📌 A **destructor** is a special member function that is **automatically called when an object is destroyed**.

It is mainly used to **free up resources** like memory, files, or database connections.

---

## ✅ Syntax:

```cpp
~ClassName() {
    // cleanup code
}
```

### 🔍 Rules:

* Same name as the class with a **tilde `~`** prefix.
* **No return type**, not even `void`.
* **No parameters** (can't be overloaded).
* Automatically called when:

  * Object **goes out of scope**
  * Program ends
  * `delete` is used on dynamic object

---

### ✅ Example:

```cpp
#include <iostream>
using namespace std;

class Demo {
public:
    Demo() {
        cout << "Constructor called!" << endl;
    }

    ~Demo() {
        cout << "Destructor called!" << endl;
    }
};

int main() {
    Demo obj;  // Constructor runs here
    cout << "Inside main function" << endl;
    return 0;  // Destructor runs here
}
```

🧾 Output:

```
Constructor called!  
Inside main function  
Destructor called!
```

---

## 🔷 Use Case: Dynamic Memory Cleanup

```cpp
class Test {
    int* arr;

public:
    Test() {
        arr = new int[5];  // allocate memory
        cout << "Memory allocated\n";
    }

    ~Test() {
        delete[] arr;      // free memory
        cout << "Memory deallocated\n";
    }
};

int main() {
    Test t1;
    return 0;
}
```

🧾 Output:

```
Memory allocated  
Memory deallocated
```

---

## 🔁 Comparison: Constructor vs Destructor

| Feature      | Constructor            | Destructor                |
| ------------ | ---------------------- | ------------------------- |
| Name         | Same as class          | Same as class with `~`    |
| When it runs | When object is created | When object is destroyed  |
| Parameters   | Can have parameters    | ❌ No parameters           |
| Return type  | ❌ No return type       | ❌ No return type          |
| Overloading  | ✅ Yes                  | ❌ No                      |
| Purpose      | Initialize object      | Clean up / free resources |

---

## ✅ Summary

| Concept      | Destructor                        |
| ------------ | --------------------------------- |
| Syntax       | `~ClassName()`                    |
| Use Case     | Free memory, close files, cleanup |
| Auto-Called  | When object goes out of scope     |
| Overloadable | ❌ No                              |

---
---

# Lec-36

## 



